# 1. 浏览器
## 1.1 性能优化

https://juejin.cn/post/6892994632968306702

### 1.1.1 CSS优化/图片优化
    加载性能：
    1.打包压缩CSS文件，减小文件体积
    2.margin,padding那种，设置单一方向样式
    3.引入外部样式时使用link，最好不要使用@import，因为前者与页面一起加载，后者需等待页面加载完毕后加载
    选择器性能：
    1.少用通配、后代选择器
    2.利用好属性继承
    渲染性能：
    1.慎用高性能属性：定位、浮动
    2.尽量减少页面重排重绘
    3.使用图标字体代替图片、不乱用web字体等
    可维护性：
    1.抽离相同属性样式，整合到class中使用
    2.将代码定义到外部css文件中
    
    图片优化：
    1. 雪碧图
    2. 懒加载
    3. base64/webp/svg
### 1.1.2 JS优化
    1. 防抖、节流：
    * 防抖: 是当事件被触发时,设定一个周期延迟动作,若期间又被触发,则重新设定周期,直到周期结束,执行动作。
    * 节流：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。
    
    2. DOM操作优化：
    * 事件委托，将子节点事件绑定到父节点上，使用了事件冒泡的特性
    * 添加dom元素时可以createDocumentFragment，最后一起加入

### 1.1.3 网络优化
    1. 减少HTTP请求数量
    2. 利用浏览器缓存
    3. 减少cookie大小，尽量用localStorage

### 1.1.4 首屏加载优化

```js
1、vue-router 路由懒加载

2、使用CDN加速，将通用库从vendor进行抽离
vue项目build之后，vendors有1M多，会导致首屏加载慢的问题，vendor会把dependencies中的依赖统一打包，导致vendors.js文件过大
像vue、axios、element-ui这些基本上不会改变的依赖我们可以把它们用cdn导入，没有必要打包到vendor.js中

1）在index.html中引入
<!-- 首屏优化，使用cdn引入外部文件 -->
<!-- vue主要的js文件-->
<script src="https://cdn.bootcss.com/vue/2.6.11/vue.min.js"></script>
<!-- element-ui的文件 -->
<link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css">
<!--  组件库引入-->
<script src="https://cdn.bootcss.com/element-ui/2.15.2/index.js"></script>
<script src="https://cdn.bootcss.com/vue-router/3.5.1/vue-router.min.js"></script>
<script src="https://cdn.bootcss.com/axios/0.21.1/axios.min.js"></script>
2）vue.config.js配置外部文件
configureWebpack:{
    externals: {
        'vue':'Vue',
        'vue-router':'VueRouter',
        'axios':'axios',
        'element-ui':'Element',
    }
}

3、Nginx开启Gzip功能
可以使网站的js、css、xml、html文件在传输的时候进行压缩，提高访问速度。Gzip的压缩页面需要浏览器和服务器双方都支持，实际上就是服务器端压缩，传到浏览器后浏览器解压并解析。现在大多数浏览器都支持Gzip
4、异步组件
5、服务端渲染SSR
6、按需加载UI库
7、webpack开启gzip压缩
8、图片懒加载减少占用带宽
9、js脚本使用异步和延迟
功能独立且不要求马上执行的js文件可以使用async，优先级低且没有依赖的js，加入defer
```

### 1.1.5 Vue性能优化

#### 1）代码层优化

```js
1. v-if v-show 区分使用
2. computed watched 区分使用
3. v-for 遍历时加:key，且避免使用v-if，因为v-for优先级高，所有的元素都会被遍历一遍再判断条件
4. 长列表性能化
有些列表数据只需要展示，不需要修改，用Object.freeze()冻结，让Vue不对其进行劫持
5. 图片懒加载
vue-lazyload
6. 事件销毁
addEventListener添加的事件不会自动销毁，需要在beforeDestroy中removeEventListener
7. 路由懒加载（首屏加载）
const Home = () => import('./Home')
8. 第三方插件按需引入
9. 窗口化技术优化无限滚动列表
10. 服务端渲染SSR（首屏加载）
```

#### 2）Webpack层优化

```js
1. 图片压缩
image-webpack-loader
2. 减少ES6转为ES5的冗余代码
babel-plugin-transform-runtime
3. 提取公共代码
CommonChunkPlugin
4. 模板预编译
直接将模板字符串变为渲染函数
5. 提取组件的CSS
6. 优化SourceMap
7. 构建结果可视化分析
webpack-bundle-analyzer
```

#### 3）基础web技术优化

```
1. 开启gzip压缩
2. 浏览器缓存
3. CDN
4. Chrome Performance查找性能瓶颈
```

### 1.1.6 一万条数据处理问题

```
1. 分页渲染，将数据分为1000组，setTimeout分页渲染
2. fragment文档碎片，先把数据塞到碎片中，再把碎片插入html中
3. 懒加载，在列表最后放个blank，触底后加载第二页
4. 虚拟列表，首次渲染10条，滚多少，加载多少
```

## 1.2 浏览器缓存机制

```
1）浏览器第一次请求资源后，服务器会返回一些缓存规则，比如expires cache-control last-modified etag等，放入响应头中返回给浏览器，浏览器根据这些规则进行缓存。
2）当浏览器再次加载资源时，先向浏览器缓存查找该请求结果，根据缓存规则来决定是否使用该缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。
3）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过资源的请求首部字段验证资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的实体，而是通知客户端可以从缓存中加载这个资源
4）强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。
5）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。

总结：
首先通过 Cache-Control 验证强缓存是否可用
如果强缓存可用，直接使用
否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的If-Modified-Since或者If-None-Match字段检查资源是否更新
若资源更新，返回资源和200状态码
否则，返回304，告诉浏览器直接从缓存获取资源
```

### 强缓存（Expires & Cache-Control）

**强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期**。

```
Expires。即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。
服务器的时间和浏览器的时间可能并不一致，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的HTTP1.1版本中被抛弃了。

在HTTP1.1中，采用了一个非常关键的字段：Cache-Control。
它和Expires本质的不同在于它并没有采用具体的过期时间点这个方式，而是采用过期时长来控制缓存，对应的字段是max-age。
private： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。
no-cache: 跳过当前的强缓存，发送HTTP请求，即直接进入协商缓存阶段。
no-store：非常粗暴，不进行任何形式的缓存。
max-age: 缓存保质期，相对时间。
s-maxage：这和max-age长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间。

值得注意的是，当Expires和Cache-Control同时存在的时候，Cache-Control会优先考虑。

当强缓存失效，就进入到协商缓存。
```

### 协商缓存（Last-Modified - If-Modified-Since & ETag - If-None-Match）

**强缓存失效之后，浏览器在请求头中携带相应的`缓存tag`来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是协商缓存。**

```
Last-Modified。即最后修改时间。
在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。浏览器接收到后，如果再次请求，会在请求头中携带If-Modified-Since字段，这个字段的值也就是服务器传来的最后修改时间。
服务器拿到请求头中的If-Modified-Since的字段后，其实会和这个服务器中该资源的最后修改时间对比:
如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。
否则返回304，告诉浏览器直接用缓存。

ETag 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。
浏览器接收到ETag的值，会在下次请求时，将这个值作为If-None-Match这个字段的内容，并放到请求头中，然后发给服务器。
服务器接收到If-None-Match后，会跟服务器上该资源的ETag进行比对:
如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。
否则返回304，告诉浏览器直接用缓存。
```

#### 两者对比

```
在精准度上，ETag优于Last-Modified。优于 ETag 是按照内容给资源上标识，因此能准确感知资源的变化。而 Last-Modified 就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况:

编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。
Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。

在性能上，Last-Modified优于ETag，也很简单理解，Last-Modified仅仅只是记录一个时间点，而 Etag需要根据文件的具体内容生成哈希值。

另外，如果两种方式都支持的话，服务器会优先考虑ETag。
```

### 缓存位置

```
浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：

1. Service Worker
离线缓存就是 Service Worker Cache，也是 PWA 的重要实现机制
2. Memory Cache
指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。
3. Disk Cache
就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。

** 比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存
** 内存使用率比较高的时候，文件优先进入磁盘

4. Push Cache
推送缓存，这是浏览器缓存的最后一道防线
```

## 1.3 浏览器本地存储

**浏览器本地存储主要分为cookie, webStorage和IndexedDB，webStorage又分为localStorage和sessionStorage**

### cookie localStorage sessionStorage

**在`HttpOnly`为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。**

| 分类           | 生命周期                                                     | 存储容量 | 存储位置                                                     |
| -------------- | :----------------------------------------------------------- | -------- | :----------------------------------------------------------- |
| cookie         | 默认保存在内存中，浏览器关闭后失效，如果设置了失效时间则到时消失 | 4KB      | 存储在客户端（如果设置过期时间，就存储在硬盘中，如果没有设置过期时间，关闭浏览器就失效，就存在内存中），每次发起请求时都会携带在头部 |
| localStorage   | 永久有效                                                     | 5MB      | 存储在客户端（默认在C盘，因此关闭浏览器不会消失），不与服务端交互 |
| sessionStorage | 仅在当前网页会话下有效，关闭浏览器或页面后被清除，刷新不会消失 | 5MB      | 在浏览器中保存                                               |

- 应用场景：localStorage 适合持久化缓存数据，比如页面的默认偏好配置等；sessionStorage 适合一次性临时数据保存，比如登录信息、表单信息维护、存储本次浏览记录。

- `localStorage`有一点跟`Cookie`一样，就是针对一个域名，即在同一个域名下，会存储相同的一段**localStorage**。

### IndexedDB

```
IndexedDB是运行在浏览器中的非关系型数据库
键值对存储。内部采用对象仓库存放数据，在这个对象仓库中数据采用键值对的方式来存储。
异步操作。数据库的读写属于 I/O 操作, 浏览器中对异步 I/O 提供了支持。
受同源策略限制，即无法访问跨域的数据库。
```

### 总结

```
1. cookie并不适合存储，而且存在非常多的缺陷。
2. Web Storage包括localStorage和sessionStorage, 默认不会参与和服务器的通信。
3. IndexedDB为运行在浏览器上的非关系型数据库，为大型数据的存储提供了接口。
```



## 1.4 前端鉴权

### 1.4.1 cookie和session的工作机制+token的工作机制

```
https://juejin.cn/post/6898630134530752520
```

### 1.4.2 localStorage sessionStorage

```
https://juejin.cn/post/7012506796489359368
```

### 1.4.3 cookie和localStorage和sessionStorage的区别

```
https://juejin.cn/post/6844903989096497159
```

## 1.5 浏览器的重排与重绘

**重排必将引起重绘，重绘不一定会引起重排。**

```
1. 浏览器使用流式布局模型 (Flow Based Layout)。
2. 浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了Render Tree。
3. 有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。
4. 由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。
```

### 1.5.1 重排

**当`Render Tree`中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为重排。**

#### 会导致重排的操作

```
* 页面首次渲染
* 浏览器窗口大小发生改变
* 元素尺寸或位置发生改变
* 元素内容变化（文字数量或图片大小等等）
* 元素字体大小变化
* 添加或者删除可见的DOM元素
* 激活CSS伪类（例如：:hover）
* 查询某些属性或调用某些方法
```

```
* clientWidth、clientHeight、clientTop、clientLeft
* offsetWidth、offsetHeight、offsetTop、offsetLeft
* scrollWidth、scrollHeight、scrollTop、scrollLeft
* scrollIntoView()、scrollIntoViewIfNeeded()
* getComputedStyle()
* getBoundingClientRect()
* scrollTo()
```

### 1.5.2 重绘

**当页面中元素样式的改变并不影响它在文档流中的位置时（例如：`color`、`background-color`、`visibility`等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。**

### 1.5.3 如何尽量避免重排和重绘

**CSS**

```
（1）使用 transform 替代 top，transform不引起重排重绘，因为GPU进程会为其开启一个新的复合图层（硬件加速）

（2）使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发重排、重绘（改变了布局

（3）避免使用table布局，可能很小的一个小改动会造成整个 table 的重新布局。

（4）尽可能在DOM树的最末端改变class，重排是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了重排的范围，使其影响尽可能少的节点。

（5）避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。

（6）将动画效果应用到position属性为absolute或fixed的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是重排，同时，控制动画速度可以选择 requestAnimationFrame，详见探讨 requestAnimationFrame。

（7）避免使用CSS表达式，可能会引发重排。

（8）将频繁重绘或者重排的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如will-change、video、iframe等标签，浏览器会自动将该节点变为图层。

（9）CSS3 硬件加速（GPU加速），使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起重排。但是对于动画的其它属性，比如background-color这些，还是会引起重排重绘的，不过它还是可以提升这些动画的性能。
```

**JavaScript**

```
（1）避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。

（2）避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。 

（3）避免频繁读取会引发重排/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
```

## 1.6 浏览器输入网址后发生了什么？

### 发生了什么？

```
1. 解析URL：分析URL中的协议、域名、端口、非法字符等

2. 判断缓存：浏览器会判断请求的资源是否在缓存中，如果在就直接用，不在就发新请求

3. DNS解析：获取URL中域名的IP地址，用户向本地发起递归请求，本地hosts -> 本地DNS服务器（如果还是没有，则向上级域名服务器发起迭代请求） -> 根域名服务器 -> 顶级域名服务器 -> 权威域名服务器，获取到之后，本地DNS服务器将IP返回给用户。

4. 根据IP建立TCP连接（三次握手）：1. 客户端向服务器发送SYN连接请求报文段和一个随机序号。2. 服务器向客户端发送SYN+ACK报文段和一个随机序号，确认连接请求。3. 客户端收到确认请求后，向服务器发送一个ACK确认报文段，表示接收到服务器的确认请求，此时连接建立。

5. HTTP请求。

6. 服务器处理，浏览器接收响应。

7. 解析响应，渲染页面：构建DOM树，CSSOM树，判断script标签属性，通过DOM和CSSOM树构建render树来布局，浏览器根据页面布局进行绘制。

8. 关闭TCP连接（四次挥手）：1. 当浏览器认为数据发送完毕后，会向服务器发送释放连接请求，客户端进入FIN-WAIT-1状态。2. 服务器收到请求后，会向客户端发送ACK包，表明要释放TCP连接，并进入CLOSE_WAIT状态，表明客户端到服务端的连接已经释放，不再接收客户端发的数据了，但是服务器仍然能够发送数据到客户端，此时客户端进入FIN-WAIT-2状态，等待服务端发送数据。3.如果服务端还有数据没发送完则会继续发送，完毕后向客户端发送释放连接请求，并进入LAST-ACK状态，等待客户端的确认。4. 客户端收到服务端的释放连接请求后，需要发出确认请求，服务端收到请求后进入CLOSED状态，此时，客户端进入TIME-WAIT状态，持续2MSL（最长报文段寿命）后，客户端进入CLOSED状态，关闭TCP连接。
```

### 为什么是三次握手 四次挥手？

+ 因为在建立连接时，客户端发送连接请求，服务端可以直接同步状态并确认，客户端再确认即可。

+ 而关闭连接时，由于是客户端先发起的关闭请求，服务端不一定发送完所有数据，只能单向确认不再客户端那边的数据，当服务端发送完数据之后，才能向客户端那边发送确认报文，表示同意关闭连接，客户端再返回确认报文，关闭TCP连接。

### 为什么不是两次握手？

双方都要确认，第一次握手，表示客户端需要发送请求，第二次握手，表示服务端收到，并且能够发送请求，它不知道客户端那边能不能接收，所以需要第三次，表示客户端收到了服务端的确认报文。

### 为什么要等2MSL？

最后一个客户端发送的ACK报文有可能丢失，需要等待一段时间，如果又收到了服务端的FIN报文，说明ACK没发过去，则重发，直到不再受到新的FIN报文。

## 1.7 跨域

### 1.7.1 定义

```js
// 什么是跨域？
就是当前页面URL与请求目标URL不同源时就叫做跨域

// 什么是同源策略？
同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。

// 同源策略限制内容有：
Cookie、LocalStorage、IndexedDB 等存储性内容
DOM 节点
AJAX 请求发送后，结果被浏览器拦截了

// 但是有三个标签是允许跨域加载资源：
<img src=XXX>
<link href=XXX>
<script src=XXX>

// 为什么浏览器要限制域访问？
为了保证用户信息的安全，防止用户存在cookie或者loacalStorage中的信息被其他网站截取导致泄露。

// 为什么要跨域？
公司内部有多个子域，需要跨域
个人请求他人接口，也需要跨域
```

### 1.7.2 解决跨域的办法

#### ++++总结++++

```
CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案
JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。
不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。
日常工作中，用得比较多的跨域方案是cors和nginx反向代理
```

#### JSONP

```
通过script标签引入一个js文件，这个js文件传入回调函数以及json数据，在引入脚本之后执行传入的回调，并将json作为参数传入，即实现跨域
```

#### 跨域资源共享(CORS)

```js
CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。
浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。

服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。
虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。

如果是带cookie跨域请求：前后端都需要进行设置：
【前端设置】根据xhr.withCredentials字段判断是否带有cookie

// 1) 简单请求
只要同时满足以下两大条件，就属于简单请求
条件1：使用下列方法之一：

GET
HEAD
POST

条件2：Content-Type 的值仅限于下列三者之一：

text/plain
multipart/form-data
application/x-www-form-urlencoded

// 2) 复杂请求
PUT/DELETE/CONNECT/OPTIONS/TRACE/PATCH;
人为设置了以下集合之外首部字段，即简单请求外的字段;
Content-Type 的值不属于下列之一，即application/x-www-form-urlencoded、multipart/form-data、text/plain。

复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。
我们用PUT向后台请求时，属于复杂请求，后台需做如下配置：

// 设置哪个源可以访问我
res.setHeader('Access-Control-Allow-Origin', origin)
// 允许携带哪个头访问我
res.setHeader('Access-Control-Allow-Headers', 'name')
// 允许哪个方法访问我
res.setHeader('Access-Control-Allow-Methods', 'PUT')
// 允许携带cookie
res.setHeader('Access-Control-Allow-Credentials', true)
// 预检的存活时间
res.setHeader('Access-Control-Max-Age', 6)
// 允许返回的头
res.setHeader('Access-Control-Expose-Headers', 'name')
if (req.method === 'OPTIONS') {
    res.end() // OPTIONS请求不做任何处理
}
```

##### options请求

```js
options 请求就是预检请求，可用于检测服务器允许的 http 方法。当发起跨域请求时，由于安全原因，触发一定条件时浏览器会在正式请求之前自动先发起 OPTIONS 请求，即 CORS 预检请求，服务器若接受该跨域请求，浏览器才继续发起正式请求。

这是因为在跨域的情况下，在浏览器发起"复杂请求"时主动发起的。跨域共享标准规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。。

// 优化options请求
方法一： 用其它的跨域方式做跨域请求，将复杂请求转为简单请求，比如JSONP等；
方法二： 对 options 请求进行缓存。
        服务器端设置 Access-Control-Max-Age 字段，那么当第一次请求该 URL 时会发出 OPTIONS 请求，浏览器会根据返回的 Access-Control-Max-Age 字段缓存该请求的 OPTIONS 预检请求的响应结果（具体缓存时间还取决于浏览器的支持的默认最大值，取两者最小值，一般为 10 分钟）。在缓存有效期内，该资源的请求（URL 和 header 字段都相同的情况下）不会再触发预检。（chrome 打开控制台可以看到，当服务器响应 Access-Control-Max-Age 时只有第一次请求会有预检，后面不会了。注意要开启缓存，去掉 disable cache 勾选。）
```

#### nginx反向代理

```
实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。
使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。
实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。
```
#### document.domain

```
因为浏览器是通过document.domain属性来检查两个页面是否同源，因此只要通过设置相同的document.domain，两个页面就可以共享Cookie
（此方案仅限主域相同，子域不同的跨域应用场景。）
```

#### webpack本地代理（Vue中使用）

```
devServer: {
  port: 7070, // 启动端口
  open: true,
  proxy: {
    '/api/': {
      target: 'https://iotmgt.evergrande.cn', //
      changeOrigin: true
    }
  }
}
```

#### websocket

#### postMessage

## 1.8 XSS攻击

### 1.8.1 什么是XSS攻击？

**`XSS` 全称是 `Cross Site Scripting`(即`跨站脚本`)，为了和 CSS 区分，故叫它`XSS`。XSS 攻击是指浏览器中执行恶意脚本(无论是跨域还是同域)，从而拿到用户的信息并进行操作。**

XSS攻击一般能够完成下面这些事：

1. 窃取`Cookie`。（如果cookie设置了HttpOnly=true时，无法通过js脚本获取cookie）
2. 监听用户行为，比如输入账号密码后直接发送到黑客服务器。
3. 修改 DOM 伪造登录表单。
4. 在页面中生成浮窗广告。

### 1.8.2 XSS攻击的三种类型

**通常情况，XSS 攻击的实现有三种方式——存储型、反射型和文档型。**

**存储型**

```
将恶意脚本存储了起来，确实，存储型的 XSS 将脚本存储到了服务端的数据库，然后在客户端执行这些脚本，从而达到攻击的效果。

常见的场景是留言评论区提交一段脚本代码，如果前后端没有做好转义的工作，那评论内容存到了数据库，在页面渲染过程中直接执行, 相当于执行一段未知逻辑的 JS 代码，是非常恐怖的。这就是存储型的 XSS 攻击。
```

**反射型**

```
指的是恶意脚本作为网络请求的一部分。

比如输入这串url：
http://sanyuan.com?q=<script>alert("你完蛋了")</script>
在服务器端会拿到q参数,然后将内容返回给浏览器端，浏览器将这些内容作为HTML的一部分解析，发现是一个脚本，直接执行，这样就被攻击了。

之所以叫它反射型, 是因为恶意脚本是通过作为网络请求的参数，经过服务器，然后再反射到HTML文档中，执行解析。和存储型不一样的是，服务器并不会存储这些恶意脚本。
```

**文档型**

```
文档型的 XSS 攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后修改里面的 html 文档！
这样的劫持方式包括WIFI路由器劫持或者本地恶意软件等。
```

### 1.8.3 如何防范XSS攻击？

明白了三种`XSS`攻击的原理，我们能发现一个共同点: 都是让恶意脚本直接能在浏览器中执行。

那么要防范它，就是要避免这些脚本代码的执行。

为了完成这一点，必须做到**一个信念，两个利用**。

#### 一个信念

```
千万不要相信任何用户的输入！无论是在前端和服务端，都要对用户的输入进行转码或者过滤。
```

#### 利用CSP

```
CSP，即浏览器中的内容安全策略，它的核心思想就是服务器决定浏览器加载哪些资源，具体来说可以完成以下功能:

1. 限制其他域下的资源加载。
2. 禁止向其它域提交数据。
3. 提供上报机制，能帮助我们及时发现 XSS 攻击。
```

#### 利用HttpOnly

```
很多 XSS 攻击脚本都是用来窃取Cookie, 而设置 Cookie 的 HttpOnly 属性后，JavaScript 便无法读取 Cookie 的值。这样也能很好的防范 XSS 攻击。
```

## 1.9 CSRF攻击

### 1.9.1 什么是CSRF攻击？

**CSRF(Cross-site request forgery), 即跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户目前的登录状态发起跨站请求。**

举个例子, 你在某个论坛点击了黑客精心挑选的小姐姐图片，你点击后，进入了一个新的页面。

那么恭喜你，被攻击了:）

#### 自动发GET请求

```html
黑客网页里面可能有一段这样的代码:
<img src="https://xxx.com/info?user=hhh&count=100">

进入页面后自动发送 get 请求，值得注意的是，这个请求会自动带上关于 xxx.com 的 cookie 信息(这里是假定你已经在 xxx.com 中登录过)。
假如服务器端没有相应的验证机制，它可能认为发请求的是一个正常的用户，因为携带了相应的 cookie，然后进行相应的各种操作，可以是转账汇款以及其他的恶意操作。
```

#### 自动发POST请求

```html
黑客可能自己填了一个表单，写了一段自动提交的脚本。
<form id='hacker-form' action="https://xxx.com/info" method="POST">
  <input type="hidden" name="user" value="hhh" />
  <input type="hidden" name="count" value="100" />
</form>
<script>document.getElementById('hacker-form').submit();</script>

同样也会携带相应的用户 cookie 信息，让服务器误以为是一个正常的用户在操作，让各种恶意的操作变为可能。
```

#### 诱导点击发送 GET 请求

```html
在黑客的网站上，可能会放上一个链接，驱使你来点击:
<a href="https://xxx/info?user=hhh&count=100" taget="_blank">点击进入修仙世界</a>

点击后，自动发送 get 请求，接下来和自动发 GET 请求部分同理。
```

**这就是CSRF攻击的原理。和XSS攻击对比，CSRF 攻击并不需要将恶意代码注入用户当前页面的html文档中，而是跳转到新的页面，利用服务器的验证漏洞和用户之前的登录状态来模拟用户进行操作。**

### 1.9.2 如何防范CSRF攻击？

#### 利用Cookie的SameSite属性

```
CSRF攻击中重要的一环就是自动发送目标站点下的 Cookie,然后就是这一份 Cookie 模拟了用户的身份。因此在Cookie上面下文章是防范的不二之选。
在 Cookie 当中有一个关键的字段，可以对请求中 Cookie 的携带作一些限制，这个字段就是SameSite。SameSite可以设置为三个值，Strict、Lax和None。

1. 在Strict模式下，浏览器完全禁止第三方请求携带Cookie。比如请求sanyuan.com网站只能在sanyuan.com域名当中请求才能携带 Cookie，在其他网站请求都不能。
2. 在Lax模式，就宽松一点了，但是只能在 get 方法提交表单况或者a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。
3. 在None模式下，也就是默认模式，请求会自动携带上 Cookie。
```

#### 验证来源站点

```
这就需要要用到请求头中的两个字段: Origin和Referer。
其中，Origin只包含域名信息，而Referer包含了具体的 URL 路径。
当然，这两者都是可以伪造的，通过 Ajax 中自定义请求头即可，安全性略差。
```

#### CSRF Token

```
首先，浏览器向服务器发送请求时，服务器生成一个字符串，将其植入到返回的页面中。
然后浏览器如果要发送请求，就必须带上这个字符串，然后服务器来验证是否合法，如果不合法则不予响应。这个字符串也就是CSRF Token，通常第三方站点无法拿到这个 token, 因此也就是被服务器给拒绝。
```

## 1.10 网络

### 1.10.1 常见状态码

    200 （成功）请求成功，返回请求的资源
    204 （无内容） 服务器成功处理了请求，但没有返回任何内容
    301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
    302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
    304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
    400 （错误请求） 服务器不理解请求的语法（一般为参数错误）。
    401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
    403 （禁止） 服务器拒绝请求。（一般为客户端的用户权限不够）
    404 （未找到） 服务器找不到请求的网页。
    500 服务器错误

#### 301 和 302的区别？

```
301，永久重定向
302，临时重定向
301比如说一个网站多个域名，通过301来跳转到正确的网站，或者之前的网址注销，但是不想流失用户
302比如说网站需要临时更换域名

* 尽量使用301跳转
因为302有可能会因为搜索引擎的原因造成网址劫持，别人通过自己的域名，偷窃显示了其他的网站内容
而301就是告诉搜索引擎之前的地址不用了，永久更换新网址
```

### 1.10.2 各版本http协议

    http0.9：
    1. 只支持发送GET请求
    2. 不支持请求头，只支持纯文本一种内容，服务器只能返回HTML格式的字符串，无法插入图片
    3. 0.9具有http典型的无状态性，每个事务独立处理，结束时释放连接
    
    http1.0：
    1. 任何格式的文件都能被发送
    2. 支持GET,POST,HEAD等请求方法
    3. 请求和响应格式发生变化，除了要传输的数据外，每次通信都包含头信息
    4. 还增加了状态码、字符集支持、多部分发送、权限、缓存、内容编码等
    5. 默认情况下还是短连接，需要使用keep-alive参数来告知服务器建立长连接，但这并不是很好的解决办法，短连接带来的建立连接成本高、连接初始发送速率慢等问题，使得http1.0性能较差
    
    http1.1：
    1. 引入了长连接（TCP连接默认不关闭，可以被多个请求复用），当双方没有活动时关闭连接，通常是客户端在最后一个请求中要求服务器关闭连接
    2. 节约带宽，http1.1支持只发送header头信息，不带任何body信息
    3. 增加了host处理，http1.1中请求消息和响应消息都支持host头域，如果不存在还会报出错误
    
    http2.0：
    1. 引入了二进制格式，数据传输方便且出错率低
    2. 压缩header体积
    3. 支持服务器推送，当客户端请求一些数据后，服务器会额外推送一些客户端可能会用到的数据

### 1.10.3 三次握手、四次挥手

#### 三次握手

```
为了确认双方的接收和发送能力正常可用

刚开始客户端处于 closed 的状态，服务端处于 listen 状态。然后
1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN（c）。此时客户端处于 SYN_Send 状态。

2、第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。

3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。

4、服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接。

1. 客户端向服务器发送SYN连接请求报文段和一个随机序号。
2. 服务器向客户端发送SYN+ACK报文段和一个随机序号，确认连接请求。
3. 客户端收到确认请求后，向服务器发送一个ACK确认报文段，表示接收到服务器的确认请求，此时连接建立。
```

![](https://img2020.cnblogs.com/blog/1937992/202006/1937992-20200601224438472-1267725684.png)

```
(1)SYN=1 表示该报文不携带数据，但消耗一个序号 seq=x，seq=x是客户端的初始化序列号，因为tcp是面向字节流的
(2)SYN=1 表示该报文不携带数据，但消耗一个序号 seq=y，seq=y是服务器的初始化序列号，ACK=1是一个确认号
ack=x+1，表示服务器下次接收到的序号希望是x+1。然后服务器进入到SYN-RCVD等待的状态
(3)ACK=1是一个确认号，seq=x+1是上一次服务器回应的序号要求，ack=y+1表示客户下一次接收到的序号希望是y+1
```

#### 四次挥手

```
1、第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。

2、第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。
 
3、第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。

4、第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态

5、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。


关闭TCP连接（四次挥手）：
1. 当浏览器认为数据发送完毕后，会向服务器发送释放连接请求，客户端进入FIN-WAIT-1状态。
2. 服务器收到请求后，会向客户端发送ACK包，表明要释放TCP连接，并进入CLOSE_WAIT状态，表明客户端到服务端的连接已经释放，不再接收客户端发的数据了，但是服务器仍然能够发送数据到客户端，此时客户端进入FIN-WAIT-2状态，等待服务端发送数据。
3.如果服务端还有数据没发送完则会继续发送，完毕后向客户端发送释放连接请求，并进入LAST-ACK状态，等待客户端的确认。
4. 客户端收到服务端的释放连接请求后，需要发出确认请求，服务端收到请求后进入CLOSED状态，此时，客户端进入TIME-WAIT状态，持续2MSL（最长报文段寿命）后，客户端进入CLOSED状态，关闭TCP连接。
```

![](https://img2020.cnblogs.com/blog/1937992/202006/1937992-20200601224737314-796511323.png)

```
这里特别需要主要的就是TIME_WAIT这个状态了，这个是面试的高频考点，就是要理解，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。
至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。
```

## 1.11 事件循环 eventloop

```js
// 浏览器是多进程的，包括浏览器主进程、GPU进程、浏览器渲染进程等
// 其中，浏览器渲染进程又是多线程的，包括GUI渲染线程、JS引擎线程、事件处理线程、定时器触发线程、HTTP请求线程等
// GUI 渲染线程、JS 引擎线程、事件处理线程是常驻线程。

// GUI与JS线程互斥

// 事件处理线程又管理着任务队列

JS是一门单线程的语言，在浏览器中由JS引擎线程执行，它的任务是按顺序执行的，如果一个任务耗时过长，那么就会导致整个线程卡住，因此任务分为两种，一种为同步任务，一种为异步任务。

"同步任务"是在主线程执行栈中排队执行的任务，具有顺序性。

"异步任务"是不进入主线程，而进入任务队列的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

"事件循环"是同步任务进入主线程，异步任务加入到队列中。主线程任务执行完毕后去执行"任务队列"中的任务，这个过程不断重复。

"任务队列"又分为宏任务和微任务，宏任务队列可以有多个、微任务队列只有一个。

首先从整个script开始，执行其中的同步代码，遇到的宏任务加入到下一个宏任务队列，遇到的微任务添加到微任务队列中，在执行完同步代码之后执行微任务。执行完成之后，进入下一次宏任务队列，遇到微任务就加入到微任务队列，遇到宏任务就加入到下一次宏任务队列，然后完成宏任务、微任务，本轮结束，再进行下一轮。

"macro-task(宏任务)"：包括整体代码 script，setTimeout，setInterval，I/O，UI rendering
"micro-task(微任务)"：Promise的then的回调函数，process.nextTick，async 函数await下面的代码等
```

![](https://pic4.zhimg.com/80/v2-b35e5a6b3f45556803d04fbe0e41b777_720w.jpg)

![](https://img-blog.csdnimg.cn/2019011100143073.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzQzMzA4,size_16,color_FFFFFF,t_70)

![](https://pic4.zhimg.com/80/v2-b35e5a6b3f45556803d04fbe0e41b777_720w.jpg)

## 1.12 HTTP协议各版本

### HTTP的特点和缺点

```
特点：无连接、无状态、灵活、简单快速

* 无连接：每一次请求都要连接一次，请求结束就会断掉，不会保持连接
* 无状态：每一次请求都是独立的，请求结束不会记录连接的任何信息(提起裤子就不认人的意思)，减少了网络开销，这是优点也是缺点
* 灵活：通过http协议中头部的Content-Type标记，可以传输任意数据类型的数据对象(文本、图片、视频等等)，非常灵活
* 简单快速：发送请求访问某个资源时，只需传送请求方法和URL就可以了，使用简单，正由于http协议简单，使得http服务器的程序规模小，因而通信速度很快

缺点：无状态、不安全、明文传输、队头阻塞

* 无状态：请求不会记录任何连接信息，没有记忆，就无法区分多个请求发起者身份是不是同一个客户端的，意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大
* 不安全：明文传输可能被窃听不安全，缺少身份认证也可能遭遇伪装，还有缺少报文完整性验证可能遭到篡改
* 明文传输：报文(header部分)使用的是明文，直接将信息暴露给了外界，WIFI陷阱就是复用明文传输的特点，诱导你连上热点，然后疯狂抓取你的流量，从而拿到你的敏感信息
* 队头阻塞：开启长连接(下面有讲)时，只建立一个TCP连接，同一时刻只能处理一个请求，那么当请求耗时过长时，其他请求就只能阻塞状态(如何解决下面有讲)
```

### 1.0

```
1. TCP连接不可复用，且一个TCP连接只能发送一次请求，当服务器响应后，就会关闭这次连接。这样导致每次请求都需要重新建立TCP连接（三次握手），影响发送速率，后面提供了一个非标准字段Connection字段来实现长连接，但是由于非标准字段，所以不同实现的行为可能不一致；
2. 支持发送的http请求方式有get、post、head；
```

### 1.1

```
1. 实现长连接，即TCP连接默认不关闭，允许被多个请求复用，不用申明Connection: keep-alive。
2. 提供管道机制，即一个TCP连接中，允许多个请求同时发送，增加并发性，但是服务器还是根据得到请求的先后顺序去进行响应，这种机制容易造成队头阻塞。
3. 请求方式增加put、patch、options、delete等。
4. 请求头新增host字段，用来处理服务器存在多个虚拟主机的情况。
5. 提供身份认真机制，许多web站点要求用户提供一个用户名—口令对才能访问存放在其服务器中的文档，这种要求称为身份认证(authentication)。HTTP提供特殊的状态码和头部来帮助Web站点执行身份认证。
```

### 2.0

```
1. 增加双工模式，即不仅客户端能够同时发送多个请求，服务端也能同时处理多个请求，解决了队头堵塞的问题；
2. 服务器推送功能，当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源
3. 支持二进制帧的格式来传递报头和数据。
4. 头信息压缩机制，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。
```

## 1.13 HTTPS加密

### 什么是HTTPS

```
HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。
PS:TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分。
```

### 优缺点

```
优点
* 内容加密，中间无法查看原始内容
* 身份认证，保证用户访问正确。如访问百度，即使DNS被劫持到第三方站点，也会提醒用户没有访问百度服务，可能被劫持
* 数据完整性，防止内容被第三方冒充或篡改
* 虽然不是绝对安全，但是现行架构下最安全的解决文案了，大大增加了中间人的攻击成本

缺点
* 要钱，功能越强大的证书费用越贵
* 证书需要绑定IP，不能在同一个IP上绑定多个域名
* https双方加解密，耗费更多服务器资源
* https握手更耗时，降低一定用户访问速度(优化好就不是缺点了)
```

### HTTP和HTTPS的区别

```
* HTTP是明文传输，不安全的，HTTPS是加密传输，安全的多
* HTTP标准端口是80，HTTPS标准端口是443
* HTTP不用认证证书免费，HTTPS需要认证证书要钱
* 连接方式不同，HTTP三次握手，HTTPS中TLS1.2版本7次，TLS1.3版本6次
* HTTP在OSI网络模型中是在应用层，而HTTPS的TLS是在传输层
* HTTP是无状态的，HTTPS是有状态的
```

## 1.14 script标签的defer, async属性

```
直接使用script脚本的话，html会按照顺序来加载并执行脚本，在脚本加载&执行的过程中，会阻塞后续的DOM渲染。
```

![](https://user-images.githubusercontent.com/9568094/31619989-a874ae42-b25b-11e7-9a80-e0f644f27849.png)

![](https://user-images.githubusercontent.com/9568094/31621391-39849b1a-b25f-11e7-9301-641b1bc07155.png)

### defer

```
如果script标签设置了该属性，则浏览器会异步的下载该文件并且不会影响到后续DOM的渲染；
如果有多个设置了defer的script标签存在，则会按照顺序执行所有的script；
defer脚本会在文档渲染完毕后，DOMContentLoaded事件调用前执行。

文档解析时，遇到设置了defer的脚本，就会在后台进行下载，但是并不会阻止文档的渲染，当页面解析&渲染完毕后。
会等到所有的defer脚本加载完毕并按照顺序执行，执行完毕后会触发DOMContentLoaded事件。
```

![](https://user-images.githubusercontent.com/9568094/31621324-046d4a44-b25f-11e7-9d15-fe4d6a5726ae.png)

### async

```
async的设置，会使得script脚本异步的加载并在允许的情况下执行
async的执行，并不会按着script在页面中的顺序来执行，而是谁先加载完谁执行。

async脚本会在加载完毕后执行。
async脚本的加载不计入DOMContentLoaded事件统计，也就是说下图两种情况都是有可能发生的
```

![](https://user-images.githubusercontent.com/9568094/31621170-b4cc0ef8-b25e-11e7-9980-99feeb9f5042.png)

![](https://user-images.githubusercontent.com/9568094/31622216-6c37db9c-b261-11e7-8bd3-79e5d4ddd4d0.png)


# 2. HTML/CSS
## 2.1 CSS优先级
    !important > 内联样式(1000) > id选择器(0100) > 类、伪类、属性选择器(0010) > 标签、伪元素选择器(0001) > 通配符、子类、兄弟选择器(0000) > 继承样式(无权值)

## 2.2 定位
+ static 默认不开启定位
+ relative 相对定位
  + 元素相对自身定位，通过left right top bottom移动
  + 不脱离文档流，在原位，不影响其他元素
  + 可以设置z-index（relative/absolute/fixed/sticky）

+ absolute 绝对定位
  + 相对于开启相对定位或者绝对定位的第一个祖先元素，没有的话就相对于body。通过left right top bottom移动
  + 脱离文档流
  + 应用：hover之后显示提示框之类的，相对于hover元素调整位置等

+ fixed 固定定位
  + 类似absolute，相对于浏览器，始终固定位置
  + 应用：简书侧边广告栏

+ sticky 粘性定位
  + 滚动到某一位置后，变为固定定位
  + 应用：客服小帮手之类的侧边栏。在滑动到下方后跟随。

## 2.3 垂直水平布局
### 定宽高

+ position: absolute + top: 50% + left: 50% + margin自身负宽高
+ position: absolute + top: 50% + left: 50% + transform: translate(-50px, -50px) 【也可以transform: translate(-50%, -50%)，即不定宽高】
+ position: absolute + top: 0 + left: 0 + right: 0 + bottom: 0 + margin: auto
+ display: flex + justify-content: center + align-items: center
+ display: grid + 子元素margin: auto

### 不定宽高

+ position: absolute + top: 50% + left: 50% + transform: translate(-50%, -50%)
+ display: flex + justify-content: center + align-items: center
+ display: flex + 子元素：margin: auto

+ display: grid + 子元素：justify-self: center + align-self: center

## 2.4 清除浮动/BFC

```css
<div class="box">
    <div class="left"></div>
    <div class="right"></div>
</div>

.box {
    border: 1px solid black;
    padding: 5px;
    width: 450px;
}
.left {
    width: 100px;
    height: 100px;
    background-color: red;
    float: left;
}
.right {
    width: 100px;
    height: 100px;
    background-color: red;
    float: right;
}

```

### 清除浮动的方法

```css
1. 将父级元素也设置浮动
.box {
            border: 1px solid black;
            padding: 5px;
            width: 450px;
            float: left
      }
缺点：无限套娃
```

```css
2. 给父级元素增加position: absolute
.box {
            border: 1px solid black;
            padding: 5px;
            width: 450px;
            position: absolute;
      }
缺点：position: absolute也脱离文档流
```

```css
3. 给父级元素设置overflow: hidden
.box {
            border: 1px solid black;
            padding: 5px;
            width: 450px;
            overflow:hidden
      }
缺点：当文本过长且包含过长英文时，会出现英文文档被隐藏的情况
```

```
4. 给父级元素设置定高（禁用）
```

```css
5. 末尾增加空元素进行clear
clear: both，元素左右两侧不允许浮动元素
<div class="box">
        <div class="left"></div>
        <div class="right"></div>
        <div class="bottomDiv"></div>
</div>

.bottomDiv {
            clear: both;
        }
缺点：增加新元素，渲染负担增加
```

```css
6. 给父级元素添加伪元素
.box::after {
            content: '';
            display: block;
            clear: both;
        }
```

### BFC

```
BFC(Block Formatting Context)，它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。
BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
```

#### 触发BFC的条件

- 根元素
- 浮动元素
- overflow不为visible
- display: inline-block, table-cell, table-caption, table, inline-table, flex
- position: absolute, fixed

#### 约束规则

```
1.内部的Box会在垂直方向上一个接一个的放置
2.内部的Box垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生折叠，不同BFC不会发生折叠。）
3.每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）
4.BFC的区域不会与float的元素区域重叠
5.计算BFC的高度时，浮动子元素也参与计算
```

#### BFC应用

```
1. 防止margin重叠
2. 清除内部浮动
3. 自适应多栏布局
两栏：
左边浮动，右边开启BFC
三栏：
左右浮动，中间开启BFC
```

## 2.5 dom 0 2 3级事件

```js
dom 0: 事件绑定(onclick,onstatechange...)、解除绑定(onclick = null)
dom 2: 事件绑定(addEventListner('click',function(){}))、解除绑定(removeEventListner)
dom 3: 
1.UI事件 当用户和页面元素交互时触发,比如load
2.blur focus 焦点事件 当元素获取焦点或失焦时触发
3.鼠标事件 双击、拖拽等
4.滚轮事件 mousewheel 滚轮滚动的时候触发的事件
5.文本事件 input input内容输入的时候触发
6.键盘事件 keydown/up 通过键盘操作触发的事件
```

## 2.6 display:none | visibility:hidden | opacity:0

```
display:none
* 元素被删除，不占据物理位置
* 不会被子元素继承，父元素没了子元素也没了
* 会引起重排和重绘
* 会构建到DOM树中，但不会构建到render树中
* 无法触发上面的事件
* transition会失效

visibility:hidden
* 元素被隐藏，占据原先位置
* 会被子元素继承，可以通过设置子元素 visibility:visible 使子元素显示出来
* 只引起重绘
* 会构建到DOM树、render树中
* 无法触发上面的事件
* transition有用

opacity:0
* 元素透明，占据原先位置
* 会被子元素继承，无法通过子元素 opacity: 1 使子元素显示出来
* 只引起重绘
* 可以触发上面的事件
* transition有用
```

## 2.7 隐藏元素的方法（全）

```
1. display: none
2. visibility: hidden
3. opacity: 0
4. position: absolute; top: -9999px; left: -9999px; 将元素移到屏幕外
5. z-index将元素置于最底层（需要开启定位）
6. transform: scale(0)，将元素缩放为0
7. transform: translate(-9999px, -9999px); 将元素移到屏幕外
```

# 3. JavaScript
## 3.1. apply,call,bind的区别
+ 三者都能够改变函数的this指向，也能借用其他对象的方法
+ 第一个参数都是this指向的对象，如果没有或者为undefined/null，则默认指向全局window
+ 三者都能传参，apply传数组，call传参数列表，apply和call是一次性传，bind可以多次传参
+ bind是修改this之后返回一个新的函数，apply、call是立即执行
+ bind返回的函数，如果这个返回的新的函数作为构造函数创建一个新的对象，那么此时 this 不再指向传入给 bind 的第一个参数，而是指向用 new 创建的实例
## 3.2. 手写apply，call，bind
+ call
```js
Function.prototype.myCall = function (context, ...args) {
    // 这里就是传入的第一个参数
    let currentObj = context ? context : window 
    // this 是调用myCall的函数，因为myCall挂载到了Function的原型上，所以所有函数都能直接.myCall，this就对应那个函数
    currentObj.fn = this 
    currentObj.fn(...args) 
    delete context.fn 
}// 测试代码
let obj = {
    height: 15
}
function fun(name, age){
    console.log(name);
    console.log(age);
    console.log(this.height);
}
fun.myCall(obj,'txf',22) // txf 22 15
fun.myCall(null) // undefined * 3
```
+ apply
```js
Function.prototype.myApply = function (context, args) {
    let currentObj = context ? context : window 
    // 这里就是传入的第一个参数
    currentObj.fn = this 
    // 将parent函数存起来,parent调用的myCall，此时this指向的就是该方法
    currentObj.fn(...args)
    delete currentObj.fn
}
let obj = {
    height: 15
}
function fun(name, age){
    console.log(name);
    console.log(age);
    console.log(this.height);
}
fun.myApply(obj,['txf',22])
fun.myApply(null)
```
+ bind
```js
// 实现bind()方法 调用bind()必须是一个函数   可以通过new修改this  new的优先级最高 bind()可以将参数分两次传递进来
Function.prototype.myBind = function (context) {
  if(typeof this !== "function") { 
    // 如果不是函数则直接抛出
      throw new TypeError('Error')
  }
  let self = this 
  // 保存this,即为fun
  let arg = [...arguments].slice(1) 
  // 将参数中除了第一个之后的全部存起来
  // bind()返回的是一个函数，所以可以使用new，并且会修改this的指向
  return function F() {
      if(this instanceof F) { 
        // 如果new执行此时即为true
          return new self(...arg, ...arguments) 
        // 返回new fun(第一次传递的参数， 第二次传递的参数) =》  arguments是执行返回的函数时的参数
      }
      return self.apply(context, [...arg, ...arguments]) // 如果没有执行new  那么直接执行parent,通过apply会将this执行最初传进来的对象a
  }
}
let obj = {
height: 15
}
function fun(name, age){
    console.log(name);
    console.log(age);
    console.log(this.height);
}
let f = fun.myBind(obj,'txf')
f(22)
```
## 3.3. 闭包
+ 有权访问另外一个函数作用域中的变量的函数叫做闭包，通常由函数嵌套产生
+ 一般的，函数在执行完毕后，内部声明的变量会随之销毁，闭包不会这样
+ 子函数引用父函数中的变量，并且父函数将子函数作为函数返回结果（不一定必须是这种情况，也可能全局定义了某个函数，然后在另一个函数中对其定义，并引用该函数的变量），此时在外部执行父函数返回了子函数，使得父函数内部的变量能够被外部访问并操作
    - 闭包的应用：
        - 防抖、节流
        - 在定时器、事件监听、Ajax请求、跨窗口通信、Web Workers或者任何异步中，只要使用了回调函数，实际上就是在使用闭包。
        - IIFE
        - 模块(return:{...})
+ 解决for循环中var导致的输出问题:

```js
for(var i = 1; i <= 5; i ++){
  setTimeout(function timer(){
    console.log(i)
  }, 0)
}

1.利用IIFE
for(var i = 1;i <= 5;i++){
  (function(j){
    setTimeout(function timer(){
      console.log(j)
    }, 0)
  })(i)
}
2.给定时器传入第三个参数，作为回调函数的参数
for(var i=1;i<=5;i++){
  setTimeout(j => {
    console.log(j)
  }, 0, i)
}
3.let
for(let i = 1; i <= 5; i ++){
  setTimeout(function timer(){
    console.log(i)
  }, 0)
}
```



## 3.4. 手写防抖、节流
+ 防抖：
  + 可用于**input.change**实时输入校验，比如输入实时查询，你不可能摁一个字就去后端查一次，肯定是输一串，统一去查询一次数据。
  + 可用于 **window.resize** 事件，比如窗口缩放完成后，才会重新计算部分 `DOM` 尺寸
```js
// 防抖
// 用户不断输入，设置防抖，用来判断用户是否停止输入，再进行下一步操作，防止不断触发事件，增加浏览器工作压力
// 当用户输入时，触发防抖，首先清除定时器，然后再设置，当用户停止触发事件后，最后一个定时器生效
let input = document.getElementById('input')
input.addEventListener('input', debounce(handle, 1000))
function debounce(func, delay){
  let timer = null
    return function(...args){
      if(timer){
        clearTimeout(timer)
      }
      timer = setTimeout(() => {
          func.apply(this, args)
      }, delay);
    }
}
function handle(e){
  console.log(e.target.value);
}
```
+ 节流
  + 用于监听 `mousemove`、 鼠标滚动等事件，通常可用于：**拖拽动画**、**下拉加载**。
```js
// 节流
// 用户开始输入后，触发节流，节流函数中判断：如果没有定时器，就创建定时器，并且在delay后调用func，然后将timer=null。如果用户不断触发事件，将不断创建新的定时器，停止触发事件后，timer=null，不再调用fuc
let input = document.getElementById('input')
input.addEventListener('input', throttle(handle, 1000))
function throttle(func, delay){
  let timer = null
  return function(...args){
    if(!timer){
      timer = setTimeout(() => {
        func.apply(this, args)
        timer = null
      }, delay);
    }
  }
}
function handle(e){
  console.log(e.target.value)
}
```

## 3.5 手写new操作符

```js
function myNew(fn, ...args){
    let obj = Object.create(fn.prototype)
    let res = fn.call(obj, ...args)
    if(res && (typeof res === "object" || typeof res === "function")){
        return res
    }
    return obj
}
function Person(name, age){
    this.name = name
    this.age = age
}
Person.prototype.sayName = function(){
    console.log(this.age)
}
let p1 = myNew(Person, 'txf','18')
console.log(p1.name)
console.log(p1)
p1.sayName()
```

```
运行结果：
txf
Person { name: 'txf', age: '18' }
18
```

## 3.6 继承

```
继承就是让子类能够拥有父类的所有属性和方法，并且能够追加或再定义属性和方法。
继承是类与类之间的关系
```

### 3.6.1 原型链继承

```js
// 存在的问题：
// 1. 引用类型的属性被所有实例共享
// 2. 在创建Child的实例时，不能向Parent传参
function Parent () {
    this.names = ['kevin', 'daisy'];
}

function Child () {

}

Child.prototype = new Parent();

var child1 = new Child();

child1.names.push('yayu');

console.log(child1.names); // ["kevin", "daisy", "yayu"]

var child2 = new Child();

console.log(child2.names); // ["kevin", "daisy", "yayu"]
```

### 3.6.2 构造函数继承

```js
// 优点：
// 1.避免了引用类型的属性被所有实例共享
// 2.可以在 Child 中向 Parent 传参

// 缺点：
// 1. 父类的原型方法不会被子类继承，而是必须在构造函数中定义，每次创建实例都会创建一遍方法，无法做到方法共用。
function Parent(name) {
    this.name = name
    this.sayHello = function() {
        console.log('hello')
    }
}
function Child(name, age){
    Parent.call(this, name)
    this.age = age
}
// Parent.prototype.sayHello = function () {
//   console.log('hello')
// }
const c1 = new Child('txf', 18)
c1.sayHello()
console.log(c1)
```

### 3.6.3 组合继承

```js
// 融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。
function Parent(name) {
    this.name = name
    this.names = ['tt','xx','ff']
}
function Child(name, age) {
    Parent.call(this, name)
    this.age = age
}
Parent.prototype.sayHello = function () {
    console.log('我是Parent原型上的方法')
}
Child.prototype = new Parent()
Child.prototype.constructor = Child
const c1 = new Child('txf', 23)
c1.sayHello()
const c2 = new Child('222txf', 24)
c2.sayHello()
console.log(c1, c2)
```

### 3.6.4 ES6类继承

```js
class Parent{
	constructor(name, age){
		this.name = name
        this.age = age
    }
    showName(){
        console.log(this.name)
    }
}
let p = new Parent('txf',18)
p.showName()

class Child extends Parent{
    constructor(name, age, salary){
        super(name, age);
        // 表示直接调用父类的构造方法，相当于ES5中的Super.call(this)
        this.salary = salary
    }
}
let s = new Child('gbl',81,20)
console.log(s)
s.showName()
```

## 3.7 原型和原型链

### 3.7.1 定义

```
原型链就是在使用一个对象的某个方法或者操作某个属性时，首先在自身上找，如果没有，则向上查找__proto__隐式原型，不断向上查找而形成的链叫做原型链，这样普通对象可以使用valueOf函数，因为Object上有valueOf，Object的prototype在普通对象的__proto__上。

每一个JS函数中都有一个prototype（原型）属性，指向这个函数的原型对象，通过这个函数产生的实例对象都有一个__proto__（隐式原型）属性，这个属性也是指向同一个原型对象，所有的实例对象的属性都会继承这个原型对象的属性，原型对象上也有一个__proto__属性，指向的objec原型对象，所有的对象属性都会继承objec原型对象属性。而object原型对象的__proto__指向的是null。当我们访问对象的某个属性时，就会从实例对象，原型对象，object原型对象上层层寻找，由此形成原型链。而原型就是原型对象上的属性。
```

```
规则:
1.js中，每个对象都有隐式原型属性__proto__，而只有函数对象才有显示原型属性prototype
2.Object,Function,Array等都是内置函数
3.__proto__是个对象，它与其构造函数的显示原型对象指向同一个对象
4.原型对象prototype有一个默认的constructor属性，指向函数对象本身，用来记录实例由哪个构造函数创建
5.使用 in 检查对象中是否含有某个属性时，如果对象中没有但是原型链中有，也会返回 true
```

### 3.7.2意义

```
原型对象的作用，是用来存放实例中共有的那部份属性、方法，可以大大减少内存消耗。在原型对象上声明方法、属性，当它创建实例时，不用为每一个实例再次创建方法、属性，纯纯浪费空间。

原型链是用来查找方法和属性的，作用域链是用来查找变量的
当一个实例对象使用某个方法或属性时，会沿着原型链查找，首先在自身上，其次查找它的__proto__指向的其构造函数的原型对象，最后查找Object.prototype.__proto__ == null
```

## 3.8 拷贝

### 3.8.1 浅拷贝

```
浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。
```

```js
1. for in 用“=”赋值，只能使基本数据类型互不影响，但是引用类型无法深拷贝

function simpleClone(obj1){
    let obj2 = Array.isArray(obj1) ? [] : {}
    for(let i in obj1){
        obj2[i] = obj1[i]
    }
    return obj2
}
let obj1 = {
    a: 1,
    b: 2,
    c: {
        d: 3
    }
}
let obj2 = simpleClone(obj1)
obj2.a = 5
obj2.c.d = 9
console.log(obj1) // 1,2,9
console.log(obj2) // 5,2,9
// 基本数据类型不会改变，但是引用数据类型会随着拷贝对象的改变而改变
```

```js
2. Object.assign()
跟for in差不多，只能拷贝基本类型
var obj1 = {
  'name' : 'zhangsan',
  'language' : [1,[2,3],[4,5]],
};
var obj2 = Object.assign({}, obj1);
obj2.name = "lisi";
obj2.language[1] = ["二","三"];
console.log('obj1',obj1) 
// obj1 { name: 'zhangsan', language: [ 1, [ '二', '三' ], [ 4, 5 ] ] }
console.log('obj2',obj2)
// obj2 { name: 'lisi', language: [ 1, [ '二', '三' ], [ 4, 5 ] ] }
```

```js
3. 解构赋值
```

```
4. 扩展运算符
let arr = [1, 2, 3];
let newArr = [...arr];//跟arr.slice()是一样的效果
```

```
5. Array.prototype.concat()   Array.prototype.slice()
```

### 3.8.2 深拷贝

```
深拷贝会另外创建一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。
深拷贝会对对象的属性进行递归复制，无论层级。
```

```js
1.JSON.parse(JSON.stringify())
用JSON.stringify()将JS对象转成JSON字符串，再用JSON.parse()把字符串解析成JS对象。
缺点：这种方法可以实现数组和对象和基本数据类型的深拷贝，但不能处理函数。
因为JSON.stringify()方法是将一个javascript值转换为一个JSON字符串，不能接受函数。其他影响如下：

var obj1 = {
  'name' : 'zhangsan',
  'language' : [1,[2,3],[4,5]],
};
var obj2 = JSON.parse(JSON.stringify(obj1));
obj2.name = "lisi";
obj2.language[1] = ["二","三"];
console.log('obj1',obj1)
// obj1 { name: 'zhangsan', language: [ 1, [ 2, 3 ], [ 4, 5 ] ] }
console.log('obj2',obj2)
// obj2 { name: 'lisi', language: [ 1, [ '二', '三' ], [ 4, 5 ] ] }
```

```js
2.递归
function deepClone(obj){
    let objClone = Array.isArray(obj)?[]:{};
    if(obj && typeof obj==="object"){
        for(key in obj){
            if(obj.hasOwnProperty(key)){
                //判断ojb子元素是否为对象，如果是，递归复制
                if(obj[key]&&typeof obj[key] ==="object"){
                    objClone[key] = deepClone(obj[key]);
                }else{
                    //如果不是，简单复制
                    objClone[key] = obj[key];
                }
            }
        }
    }
    return objClone;
}    
let a=[1,2,3,4],
    b=deepClone(a);
a[0]=2;
console.log(a,b);
// [2,2,3,4] [1,2,3,4]
```

```
3. Object.assign({}, obj) ||  arr2 = arr1.concat() || arr2 = arr1.slice() || obj2 = {...obj1, key: value} 扩展运算符 
【只有一层基本数据时，才算深拷贝】
```

```
4. 手动赋值（不建议）
```

## 3.9 数据类型

### 3.9.1 typeof, instanceof

#### 3.9.1.1 typeof

```js
'1'.toString()为什么可以调用？

var s = new Object('1')
s.toString()
s = null
```

```js
* 对于原始类型来说，除了 null 都可以调用typeof显示正确的类型。
typeof null = 'object' // js设计遗留问题

* 对于引用数据类型，除了函数之外，都会显示"object"，因此无法用typeof判断数组
typeof console.log // 'function'
typeof {} // 'object'
typeof [] // 'object'
```

#### 3.9.1.2 instanceof

```js
* 所以一般使用instanceof判断引用类型，它基于原型链查询，只要处于原型链中，就是true，可以判断是否为实例
const Person = function(){}
const p1 = new Person()
p1 instanceof Person // true

let str1 = 'hello world'
str1 instanceof String // false


var str2 = new String('hello world')
str2 instanceof String // true

* instanceof能否判断基本数据类型？
也能，不过就是自定义instanceof行为的一种方式，这里将原有的instanceof方法重定义，换成了typeof，因此能够判断基本数据类型。
class PrimitiveNumber {
  static [Symbol.hasInstance](x) {
    return typeof x === 'number'
  }
}
console.log(111 instanceof PrimitiveNumber) // true
```

##### 手写instanceof

```js
function myInstanceof(left, right) {
    //基本数据类型直接返回false
    if(typeof left !== 'object' || left === null) return false;
    //getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象
    let proto = Object.getPrototypeOf(left);
    while(true) {
        //查找到尽头，还没找到
        if(proto == null) return false;
        //找到相同的原型对象
        if(proto == right.prototype) return true;
        proto = Object.getPrototypeOf(proto);
    }
}
console.log(myInstanceof("111", String)); //false
console.log(myInstanceof(new String("111"), String));//true
```

### 3.9.2 Object.is和===的区别

```js
Object在严格等于的基础上修复了一些特殊情况下的失误，具体来说就是+0和-0，NaN和NaN。

console.log(Object.is(NaN,NaN)); // t
console.log(Object.is(+0,-0)); // f
console.log(NaN === NaN); // f
console.log(+0 === -0); // t

源码如下：
function is(x, y) {
  if (x === y) {
    //运行到1/x === 1/y的时候x和y都为0，但是1/+0 = +Infinity， 1/-0 = -Infinity, 是不一样的
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    //NaN===NaN是false,这是不对的，我们在这里做一个拦截，x !== x，那么一定是 NaN, y 同理
    //两个都是NaN的时候返回true
    return x !== x && y !== y;
  }
```

#### === 和 ==

```js
===叫做严格相等，是指：左右两边不仅值要相等，类型也要相等，例如'1'===1的结果是false，因为一边是string，另一边是number。
==不像===那样严格，对于一般情况，只要值相等，就返回true，但==还涉及一些类型转换，它的转换规则如下：
两边的类型是否相同，相同的话就比较值的大小，例如1==2，返回false
判断的是否是null和undefined，是的话就返回true
判断的类型是否是String和Number，是的话，把String类型转换成Number，再进行比较
判断其中一方是否是Boolean，是的话就把Boolean转换成Number，再进行比较
如果其中一方为Object，且另一方为String、Number或者Symbol，会将Object转换成字符串，再进行比较
console.log({a: 1} == true);//false
console.log({a: 1} == "[object Object]");//true

```



### 3.9.3 类型转换

#### js中类型转换由哪几种？

```js
1.转换成数字
2.转换成布尔值
3.转换成字符串

Number -> Boolean: 
除了0,-0,NaN，都为true

String -> Boolean:
除了空串都为true

undefined, null -> Boolean:
false

引用类型 -> Boolean:
true

number -> String:
1 -> '1'

boolean,symbol,函数 -> String:
'true'

Array -> String:
[1,2] => '1,2'

Object -> String:
'[object Object]'

String -> Number:
'1' => 1, 'a1' => NaN

Array -> Number:
空数组为0，存在一个元素且为数字转数字。其他情况NaN

null -> Number: 
0

除了数组的引用类型 -> Number: 
NaN

Symbol -> Number:
报错
```

### 3.9.4 一些特殊的打印输出

```js
console.log(Boolean(0)); // false
console.log(Boolean('')); // false
console.log(Boolean({})) // true
console.log(Boolean([])) // true
console.log(![]) // false
console.log((! + [] + [] + ![]), typeof (! + [] + [] + ![])) // truefalse string
console.log((! + [] + [] + ![]).length) // 9
console.log({} + []) // [object Object]
console.log([] + {}); // [object Object]
console.log([1] in [1,2]) // true
console.log([2] in [1,2]) // false
console.log(['length'] in [1,2]) // true
console.log(1 in [1,2]) // true
```

#### 3.9.4.1  [] == ![] 为什么为true？

```
1. 右边有！，优先级高于==，将![]转换为布尔值，为false，再转换为number 0
2. 左边是对象，调用[].valueOf().toString()转换为空字符串''，再转换为false，再转换为number 0
3. 左右两边 0==0，因此为true
```

### 3.9.5 双等号左右两边转换规则

```js
1. null == undefined // true
2. 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值，false为0，true为1
3. 如果一个操作数是字符串，另一个是数值，那么将字符串转换为数值
4. 如果一个操作数是对象，另一个不是，则调用valueOf()或者toString()方法，用得到的基本类型根据前几条规则比较
```

## 3.10 对象

### 3.10.1 对象的可枚举属性与不可枚举属性

```
在JavaScript中，对象的属性分为可枚举和不可枚举之分，它们是由属性的enumerable值决定的。
* 可枚举属性是指那些内部enumerable 标志设置为 true 的属性。对于通过直接的赋值和属性初始化的属性，该标识值默认为即为 true。
* 但是对于通过 Object.defineProperty 等定义的属性，该标识值默认为 false。
```

### 3.10.2 对象常用方法

#### assign()

```js
语法：
Object.assign(target, ...sources)
用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。
【返回目标对象】
* 如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。
* Object.assign 方法只会拷贝【源对象自身】的并且【可枚举】的属性到目标对象
* 只深拷贝第一层的基本类型
const target = { a: 1, b: 2 };
const source = { b: 4, c: 5 };
console.log(returnedTarget);
// expected output: Object { a: 1, b: 4, c: 5 }

Object.assign()常见用途：
1.为对象添加属性
class Point{
   constructor(x,y){
      Object.assign(this,{x,y});
   }
}
2.为对象添加方法
// 方法也是对象
// 将两个方法添加到类的原型对象上
// 类的实例会有这两个方法
Object.assign(SomeClass.prototype,{
    someMethod(arg1,arg2){...},
    anotherMethod(){...}
});
3.克隆对象
//克隆对象的方法
function clone(origin){
    //获取origin的原型对象
    let originProto = Obejct.getPrototypeOf(origin);
    //根据原型对象，创建新的空对象，再assign
    return Object.assign(Object.create(originProto),origin);
}
4.为属性指定默认值
// 默认值对象
const DEFAULTS = {
   logLevel : 0,
   outputFormat : 'html'
};
 
// 利用assign同名属性会覆盖的特性，指定默认值，如果options里有新值的话，会覆盖掉默认值
function processContent(options){
   options = Object.assign({},DEFAULTS,options);
   console.log(options);
   //...
}
```

#### create()

```js
语法：
Object.create(proto，[propertiesObject])
创建一个新对象，使用现有的对象来提供新创建的对象的__proto__
proto表示新建对象的原型对象，即该参数会被赋值到目标对象的原型上
propertiesObject为添加到新创建对象的可枚举属性（即其自身的属性，而不是原型链上的枚举属性）对象的属性描述符以及相应的属性名称
【返回一个新对象，带着指定的原型对象和属性】
const person = {
  isHuman: false,
  printIntroduction: function() {
    console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);
  }
};
const me = Object.create(person);
me.name = 'Matthew'; // "name" is a property set on "me", but not on "person"
me.isHuman = true; // inherited properties can be overwritten
me.printIntroduction();
// expected output: "My name is Matthew. Am I human? true"
console.log(me)
// Object { name: "Matthew", isHuman: true }
console.log(me.__proto__)
// Object { isHuman: false, printIntroduction: Object {  } }
```

#### defineProperty()

```js
语法：
Object.defineProperty(obj, prop, descriptor)
直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。
* obj为要定义属性的对象
* prop为要定义或修改的属性的名称或 Symbol
* descriptor为要定义或修改的属性描述符
【返回被传递给函数的对象】

* 对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个具有值的属性，该值可以是可写的，也可以是不可写的。存取描述符是由 getter 函数和 setter 函数所描述的属性。一个描述符只能是这两者其中之一；不能同时是两者。
【数据描述符】：
1.configurable: 表示对象的属性是否可以被删除，以及除 writable 特性外的其他特性是否可以被修改，把 configurable 修改成false 是单向操作， 无法撤销！
2.enumerable：定义了对象的属性是否可以在 for...in 循环和 Object.keys() 中被枚举
【上面两种描述符是共享的】
3.value：该属性对应的值
4.writable：属性设置为 false 时，该属性被称为“不可写的”。它的value不能被重新赋值。
【存取描述符】：
1.getter
2.setter
* configurable、enumerable 和 writable 的默认值都是 false。
* value、get 和 set 字段的默认值为 undefined。
const object1 = {};
Object.defineProperty(object1, 'property1', {
  value: 42,
  writable: false
});
object1.property1 = 77;
// throws an error in strict mode
console.log(object1.property1);
// expected output: 42
```

#### getOwnPropertyDescriptor()

```js
语法：
Object.getOwnPropertyDescriptor(obj, prop)
返回指定对象上一个【自身属性】对应的属性描述符。
o = {};
Object.defineProperty(o, "baz", {
  value: 8675309,
  writable: false,
  enumerable: false
});
d = Object.getOwnPropertyDescriptor(o, "baz");
// d {
//   value: 8675309,
//   writable: false,
//   enumerable: false,
//   configurable: false
// }
```

#### getOwnPropertyNames()

```js
语法：
Object.getOwnPropertyNames(obj)
返回一个由指定对象的【所有自身属性的属性名】（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的【数组】

var arr = ["a", "b", "c"];
console.log(Object.getOwnPropertyNames(arr).sort()); 
// ["0", "1", "2", "length"]

//不可枚举属性
var my_obj = Object.create({}, {
  getFoo: {
    value: function() { return this.foo; },
    enumerable: false
  }
});
my_obj.foo = 1;
console.log(Object.getOwnPropertyNames(my_obj).sort()); // ["foo", "getFoo"]
```

#### hasOwnProperty()

```js
语法：
obj.hasOwnProperty(prop)
方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）
o = new Object();
o.hasOwnProperty('prop'); // 返回 false
o.prop = 'exists';
o.hasOwnProperty('prop'); // 返回 true
delete o.prop;
o.hasOwnProperty('prop'); // 返回 false
```

#### keys()

```js
语法：
Object.keys(obj)
返回一个由一个给定对象的【自身可枚举属性】组成的【数组】，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致
// simple array
var arr = ['a', 'b', 'c'];
console.log(Object.keys(arr)); // console: ['0', '1', '2']

// array like object
var obj = { 0: 'a', 1: 'b', 2: 'c' };
console.log(Object.keys(obj)); // console: ['0', '1', '2']

// array like object with random key ordering
var anObj = { 100: 'a', 2: 'b', 7: 'c' };
console.log(Object.keys(anObj)); // console: ['2', '7', '100']

// getFoo is a property which isn't enumerable
var myObj = Object.create({}, {
  getFoo: {
    value: function () { return this.foo; }
  }
});
myObj.foo = 1;
console.log(Object.keys(myObj)); // console: ['foo']
```

#### values()

```js
语法：
Object.values(obj)
返回一个给定对象【自身的所有可枚举属性值】的数组
var obj = { foo: 'bar', baz: 42 };
console.log(Object.values(obj)); // ['bar', 42]

// array like object
var obj = { 0: 'a', 1: 'b', 2: 'c' };
console.log(Object.values(obj)); // ['a', 'b', 'c']

// array like object with random key ordering
// when we use numeric keys, the value returned in a numerical order according to the keys
var an_obj = { 100: 'a', 2: 'b', 7: 'c' };
console.log(Object.values(an_obj)); // ['b', 'c', 'a']

// getFoo is property which isn't enumerable
var my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; } } });
my_obj.foo = 'bar';
console.log(Object.values(my_obj)); // ['bar']

// non-object argument will be coerced to an object
console.log(Object.values('foo')); // ['f', 'o', 'o']
```



## 3.10 数组

### 3.10.1 arguments

```js
arguments本身并不是数组，不能调用数组方法，它是个key从0开始顺序排列的对象，由callee和length属性，称其为类数组
常见类数组还有：
1.用getElementByTagName/ClassName()获取的HTML元素集合
2.querySelector()获得的nodeList

将类数组转为数组的方法:
1.Array.prototype.slice.call(arguments)
2.Array.from(arguments)
3.Array.from(new Set(arguments))
数组去重
4.ES6扩展运算符
5.Array.prototype.concat.apply([],arguments)
```

### 3.10.2 判断数组的方法

```js
1. Array.isArray(arr) // true or false
2. arr instanceof Array // true or false
3. Object.prototype.toString.call(arr) == 'Object Array'
4. arr.constructor === Array // true of false
```

### 3.10.3 forEach

```
1.forEach()没有返回值，其中的回调中的return也是无效的
中断forEach的方法：
1.try 
2.使用some和every,some在return true时停止循环，every在return false时停止循环
2.forEach()会跳过空值
即不会对空元素进行回调
```

```javascript
let arr = [1,3,5,8,10,200]
let res = arr.forEach((item, index) => {
    console.log(`数组第${index+1}个元素是${item}`)
})
console.log(res) // undefined
```

### 3.10.4 判断数组中是否包含某个值

```js
let arr = [1,2,3,4]

1. array.indexOf
let index = arr.indexOf(3)
console.log(index) // 2

2. array.includes(searchElement[,fromIndex])
let res = arr.includes(1)
console.log(res) // true

3. array.find(callback[,thisArg])
// 返回数组中满足条件的第一个元素的值，如果没有，返回undefined
let res = arr.find(item => {
    return item > 3
})
console.log(res) // 4

4. array.findIndex(callback[,thisArg])
// 返回数组中满足条件的第一个元素的下标，如果没有找到，返回-1
let result = arr.findIndex(item => {
    return item > 3
});
console.log(result); // 3
```

### 3.10.5 数组扁平化 flat

```js
let arr = [1,[2,[3,4,[5,6]]],7,[8,9,[10,11]]]

1. ES6中flat方法
arr = arr.flat(Infinity) 

2. 递归
const flattern = arr=>{
    const res = [];
    arr.forEach((item)=>{
        if(Array.isArray(item)){
            res.push(...flattern(item));
        }else{
            res.push(item);
        }
    })
    return res;
}
flattern(arr);

3. reduce函数迭代
function myFlat(arr){
    return arr.reduce((pre, cur) => {
        return pre.concat(Array.isArray(cur) ? myFlat(cur) : cur)
    }, [])
}

4. 扩展运算符
while(arr.some(Array.isArray)){
    arr = [].concat(...arr)
}

5. join split map
array.join().split(',').map(Number)

6. toString split map
array.toString().split(',').map(Number)
```

### 3.10.6 filter map reduce

```js
  let nums = [14,67,43,2,566,12,100]
  // 1.filter()，【过滤器】，内部遍历数组，传出符合条件的元素
  // filter函数参数为一个回调函数，回调函数的参数为每次过滤的数组元素
  // 回调函数内部返回布尔值，返回true，将元素加入新数组，返回false，不加入
  // 使用新变量接收过滤后的数组
  let newNums = nums.filter(num => num < 100)
  console.log(newNums);
  //  [14, 67, 43, 2, 12]

  // 2.map()，【更新数组】，内部遍历数组，根据返回值更新处理后的每个元素的值
  // map函数参数为一个回调函数，回调函数的参数为每次遍历的数组元素
  // 内部返回对元素的操作，并修改该元素，直到遍历完毕
  // 使用新变量接收更新后的数组
  let newNums2 = newNums.map(n => n*2)
  console.log(newNums2);
  // [28, 134, 86, 4, 24]

  // 3.reduce()，【对数组中的所有元素进行汇总】
  // 第一个参数为回调函数，第二个参数为初始化值
  // 这里reduce会遍历5次
  // 第一次： preValue: 0  n: 28
  // 第二次： preValue:第一次return的值 n:134
  // ····
  // 第五次： preValue:第四次return的值 n:24
  let newNums3 = newNums2.reduce((preValue, n) => {
    return preValue + n
  },0)
  console.log(newNums3);
  // 276
  console.log(28+134+86+4+24);
  // 276
```

### 3.10.7 数组常用方法

#### concat()

```js
参数：
(value1[, value2[, ...[, valueN]]])

用于合并两个或多个数组，参数可以任意数据类型
【返回一个新数组】【此方法不会更改原数组】
const array1 = ['a', 'b', 'c'];
const array2 = ['d', 'e', 'f'];
const array3 = array1.concat(array2);

console.log(array3);
// expected output: Array ["a", "b", "c", "d", "e", "f"]
```

#### every()

```js
参数：
(callback(element[, index[, array]])[, thisArg])

测试一个数组内是否所有元素都满足回调函数内的条件
【返回一个布尔值】【不会检测空数组】
const arr = [1,5,10,22,35,46,66]
const flag = arr.every(item => item < 65)
console.log(flag); // false
```

#### some()

```js
参数：
(callback(element[, index[, array]])[, thisArg])

测试一个数组内是否有元素满足回调函数内的条件
【返回一个布尔值】【不会检测空数组】
const arr = [1,2,4,5,18,33]
const flag = arr.some(item => item === 1)
console.log(flag); // true
```

#### fill()

```js
参数：
(value[, start[, end]])

用固定值填充一个数组中从起始索引到终止索引内的全部元素。【左闭右开】
const array1 = [1, 2, 3, 4];
console.log(array1.fill(0, 2, 4)); // expected output: [1, 2, 0, 0]
console.log(array1.fill(5, 1)); // expected output: [1, 5, 5, 5]
console.log(array1.fill(6)); // expected output: [6, 6, 6, 6]
```

#### filter()

```js
参数：
(callback(element[, index[, array]])[, thisArg])

创建一个新数组，其包含通过所提供函数实现的测试的所有元素
【返回通过测试的元素组成的新数组】【如果没有元素通过，则返回空数组】
const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];
const result = words.filter(word => word.length > 6);
console.log(result); // expected output: Array ["exuberant", "destruction", "present"]
```

#### find() && findIndex()

```js
参数：
(callback[, thisArg])

返回数组中满足提供的测试函数的第一个元素的值，否则返回 undefined。
【findIndex则返回第一个元素的索引，否则返回-1】
const array1 = [5, 12, 8, 130, 44];
const found = array1.find(element => element > 10);
const foundIndex = array1.findIndex(element => element > 10)
console.log(found); // expected output: 12
console.log(foundIndex); // 1
```

##### findeIndex和indexOf的区别：

```
* findIndex可以增加条件，indexOf只能查找相等的值
* 都是返回符合条件的第一个元素的索引
```

#### flat()

```js
参数：
([depth])

按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。
【返回新数组】【不改变原数组】
const arr1 = [0, 1, 2, [3, 4]];
console.log(arr1.flat()); // expected output: [0, 1, 2, 3, 4]
const arr2 = [0, 1, 2, [[[3, 4]]]];
console.log(arr2.flat(3)); // expected output: [0, 1, 2, 3, 4]
```

#### forEach()

```js
参数：
(callback(currentValue [, index [, array]])[, thisArg])
currentValue为当前正在处理的元素、index为当前正在处理的元素索引，array为正在操作的数组

对数组的每个元素执行一次给定的函数。
【返回undefined】【无法使用return跳出循环】【可以使用try...catch跳出循环】【不改变原数组】
* 如果 thisArg 参数有值，则每次 callback 函数被调用时，this 都会指向 thisArg 参数。如果省略了 thisArg 参数，或者其值为 null 或 undefined，this 则指向全局对象。
* 调用 forEach 后添加到数组中的项不会被 callback 访问到。
function logArrayElements(element, index, array) {
  console.log('a[' + index + '] = ' + element);
}
// 注意索引 2 被跳过了，因为在数组的这个位置没有项
[2, 5, , 9].forEach(logArrayElements);
// logs:
// a[0] = 2
// a[1] = 5
// a[3] = 9
```

#### join()

```js
参数：
([separator])
指定一个字符串来分隔数组的每个元素。如果需要，将分隔符转换为字符串。如果缺省该值，数组元素用逗号（,）分隔。如果separator是空字符串("")，则所有元素之间都没有任何字符。

将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。
【返回字符串】
const elements = ['Fire', 'Air', 'Water'];
console.log(elements.join()); // expected output: "Fire,Air,Water"
console.log(elements.join('')); // expected output: "FireAirWater"
console.log(elements.join('-')); // expected output: "Fire-Air-Water"
```

#### map()

```js
参数：
(function callback(currentValue[, index[, array]]) {
 // Return element for new_array 
}[, thisArg])

创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。
【返回新数组】【不改变原数组】
const array1 = [1, 4, 9, 16]; // pass a function to map
const map1 = array1.map(x => x * 2);
console.log(map1); // expected output: Array [2, 8, 18, 32]
```

#### pop() & push()

```js
pop():
删除数组最后一个元素
push():
向数组末尾添加一个或多个元素
【返回新数组长度】
const animals = ['pigs', 'goats', 'sheep'];
const count = animals.push('cows');
console.log(count); // expected output: 4
console.log(animals); // expected output: Array ["pigs", "goats", "sheep", "cows"]
animals.push('chickens', 'cats', 'dogs');
console.log(animals); // expected output: Array ["pigs", "goats", "sheep", "cows", "chickens", "cats", "dogs"]
```

#### reduce()

```js
参数：
(callback(accumulator, currentValue[, index[, array]])[, initialValue])

对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。
【返回函数累计处理的结果】
const array1 = [1, 2, 3, 4];
const reducer = (previousValue, currentValue) => previousValue + currentValue;// 1 + 2 + 3 + 4
console.log(array1.reduce(reducer));// expected output: 10 // 1 + 2 + 3 + 4
console.log(array1.reduce(reducer, 5));// 5 + 1 + 2 + 3 + 4 expected output: 15
```

#### shift() & unshift()

```
shift():
删除数组第一个元素
unshift():
向数组开头添加一或多个元素，返回数组新长度
```

#### slice()

```js
参数：
([begin[, end]])

返回一个新的数组对象，这一对象是一个由 begin 和 end （索引）决定的原数组的浅拷贝。
【不改变原数组】【左闭右开】【返回新数组】
const animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];
console.log(animals.slice(2)); 
// expected output: Array ["camel", "duck", "elephant"]
console.log(animals.slice(2, 4)); 
// expected output: Array ["camel", "duck"]
console.log(animals.slice(1, 5)); 
// expected output: Array ["bison", "camel", "duck", "elephant"]
console.log(animals.slice(-2)); 
// expected output: Array ["duck", "elephant"]
console.log(animals.slice(2, -1)); 
// expected output: Array ["camel", "duck"]
```

#### splice()

```js
参数：
(start[, deleteCount[, item1[, item2[, ...]]]])

通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。
【改变原数组】【返回被删除的元素组成的数组，没有删除元素则返回空数组】
const months = ['Jan', 'March', 'April', 'June'];
months.splice(1, 0, 'Feb');
// inserts at index 1
console.log(months);
// expected output: Array ["Jan", "Feb", "March", "April", "June"]
months.splice(4, 1, 'May');
// replaces 1 element at index 4
console.log(months);
// expected output: Array ["Jan", "Feb", "March", "April", "May"]
```

### 3.10.8 哪些数组方法会改变原数组？

```js
1.pop() 
2.shift() 
3.push() 
4.unshift() 
5.sort()
6.splice()
7.reverse()
这些方法也是Vue中的响应式方法
```

### 3.10.9 数组去重

#### 基本数据类型

```js
const arr = [1,2,3,4,5,4,3,5,8]
1. 扩展运算符+Set
let newArr = [...new Set(arr)]
2. Set
let newArr = Array.from(new Set(arr))
3. 双层for循环+splice
NaN和{}不去重，null直接删掉
function removeDuplicate(arr) {
    let length = arr.length
    for(let i = 0; i < len; i++) {
        for (let j = i + 1; j < len; j++) {
            if (arr[i] === arr[j]) {
                arr.splice(j, 1)
                len--
                j--
            }
        }
    }
    return arr
}
4. indexOf
function removeDuplicate(arr) {
	const newArr = []
    arr.forEach(item => {
        if (newArr.indexOf(item) == -1) {
            newArr.push(item)
        }
    })
    return newArr
}
5. Map
function arrayNonRepeatfy(arr) {
  let map = new Map();
  let newArr = [];  // 数组用于返回结果
  arr.forEach(item => {
      if (!map.has(item)) {
          map.set(item, true)
          newArr.push(item)
      }
  })
  return newArr
}
6. filter
// indexOf返回的是第一次出现的索引，所以当他第一次出现时,arr.indexOf(item) === index，后面出现的元素，在indexOf后，返回的是前面的index，跟当前元素的index不相等
function removeD(arr) {
    return arr.filter((item, index) => {
        return arr.indexOf(item) === index
    })
}
```

#### 数组内对象去重

```js
var arr = [{
      key: '01',
      value: '乐乐'
   }, {
      key: '02',
      value: '博博'
   }, {
      key: '03',
      value: '淘淘'
   },{
      key: '04',
      value: '哈哈'
   },{
      key: '01',
      value: '乐乐'
   }];

   //  方法1：利用对象访问属性的方法，判断对象中是否存在key
   var result = [];
   var obj = {};
   for(var i =0; i<arr.length; i++){
      if(!obj[arr[i].key]){
         result.push(arr[i]);
         obj[arr[i].key] = true;
      }
   }
   console.log(result); // [{key: "01", value: "乐乐"},{key: "02", value: "博博"},{key: "03", value: "淘淘"},{key: "04", value: "哈哈"}]

   //  方法2：利用reduce方法遍历数组,reduce第一个参数是遍历需要执行的函数，第二个参数是item的初始值
      var obj = {};
      arr = arr.reduce(function(item, next) {
      obj[next.key] ? '' : obj[next.key] = true && item.push(next);
      return item;
   }, []);
   console.log(arr); // [{key: "01", value: "乐乐"},{key: "02", value: "博博"},{key: "03", value: "淘淘"},{key: "04", value: "哈哈"}]
```

## 3.11 JS中this的理解

### 原生JS函数中的this

```js
1. 全局上下文
全局上下文默认this指向window, 严格模式下指向undefined。
2. 直接调用函数
let obj = {
    a(){
        console.log(this)
    }
}
let func = obj.a
func() 
this相当于1中情况
3. 对象形式调用
上面的例子，直接
obj.a()
输出的就是这个对象
4. DOM事件绑定
this默认指向绑定事件的元素
5. new + 构造函数
this指向实例对象
6. 箭头函数
箭头函数没有this，也不能绑定。里面的this会指向当前最近的非箭头函数的this，找不到就是window(严格模式是undefined)
let obj = {
  a: function() {
    let do = () => {
      console.log(this);
    }
    do();
  }
}
obj.a(); // 找到最近的非箭头函数a，a现在绑定着obj, 因此箭头函数中的this是obj
```

```js
关于this的例子：
this总是代表它的直接调用者(js的this是执行上下文), 例如 obj.func ,那么func中的this就是obj
1.--------------------
如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window
function a(){
    var user = "追梦子";
    console.log(this.user); //undefined
    console.log(this); //Window
}
a();
2.-----------------------
如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。
var user = '111'
var o = {
    user:"追梦子",
    fn:function(){
        console.log(this.user); 
    }
}
o.fn(); // 追梦子
var f = o.fn
f() // 111
3.-------------------------------
如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象
var o = {
    a:10,
    b:{
        // a:12,如果这里没有被注释，那么下面输出的将是12
        fn:function(){
            console.log(this.a); //undefined
        }
    }
}
o.b.fn();
4.--------------------------------
var o = {
    a:10,
    b:{
        a:12,
        fn:function(){
            console.log(this.a); //undefined
            console.log(this); //window
        }
    }
}
var j = o.b.fn;
j();
```

###  ES6中箭头函数的this

```js
（1）函数体内的this对象，继承的是外层代码块的this。
（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。
（5）箭头函数没有自己的this，所以不能用call()、apply()、bind()这些方法去改变this的指向.
```

## 3.12 JS中内存的存储

```js
基本数据类型用栈存储，引用数据类型用堆存储。闭包变量是存在堆内存中的。

具体而言，以下数据类型存储在栈中：
boolean,null,undefined,number,string,symbol,bigint
所有的对象数据类型存放在堆中。

* 为什么不用栈来保存引用类型呢？
首先，对于系统栈来说，它的功能除了保存变量之外，还有创建并切换函数执行上下文的功能。如果采用栈来存储相对基本类型更加复杂的对象数据，那么切换上下文的开销将变得巨大
不过堆内存虽然空间大，能存放大量的数据，但与此同时垃圾内存的回收会带来更大的开销
```

### 3.12.1 V8引擎如何进行垃圾内存的回收

#### V8内存限制

```js
JS采用自己的一套垃圾回收算法进行自动的内存管理
V8引擎具有内存限制，64位下1.4G，32位下0.7G
这是为什么？
究其根本，是由两个因素所共同决定的，一个是JS单线程的执行机制，另一个是JS垃圾回收机制的限制。
首先JS是单线程运行的，这意味着一旦进入到垃圾回收，那么其它的各种运行逻辑都要暂停; 另一方面垃圾回收其实是非常耗时间的操作。
```

#### 新生代内存

```
V8 把堆内存分成了两部分进行处理——新生代内存和老生代内存。顾名思义，新生代就是临时分配的内存，存活时间短， 老生代是常驻内存，存活的时间长。V8 的堆内存，也就是两个内存之和。
首先是新生代的内存，刚刚已经介绍了调整新生代内存的方法，那它的内存默认限制是多少？在 64 位和 32 位系统下分别为 32MB 和 16MB

回收算法：
Scavenge算法
首先将新生代内存空间一分为二：from 和 to
其中From部分表示正在使用的内存，To 是目前闲置的内存。
当进行垃圾回收时，V8 将From部分的对象检查一遍，如果是存活对象那么复制到To内存中(在To内存中按照顺序从头放置的)，如果是非存活对象直接回收即可。
当所有的From中的存活对象按照顺序进入到To内存之后，From 和 To 两者的角色对调，From现在被闲置，To为正在使用，如此循环。

缺陷：内存只能使用新生代内存的一半，但是它只存放生命周期短的对象，这种对象一般很少，因此时间性能非常优秀
```

#### 老生代内存

```
新生代中的变量如果经过多次回收后依然存在，那么就会被放入到老生代内存中，这种现象就叫晋升。

回收算法：
1.进行标记-清除。首先会遍历堆中的所有对象，对它们做上标记，然后对于代码环境中使用的变量以及被强引用的变量取消标记，剩下的就是要删除的变量了，在随后的清除阶段对其进行空间的回收。
2.整理内存碎片。在清除阶段结束后，把存活的对象全部往一端靠拢
```

### 3.12.2 V8执行JS代码的过程

```js
1. 在 V8 引擎拿到 JS 代码之后，解析器（Parser）会对其进行词法分析（将 JS 代码拆分成对应的 Token）和语法分析（在进行词法分析转为 Token 之后，解析器继续根据生成的 Token 生成对应的 AST）。
2. 在解析器（Parser）将 JS 代码解析成 AST 之后，解释器（Ignition）根据 AST 来生成字节码（也称中间码）。
3. 由解释器逐行执行字节码，遇到热点代码启动编译器进行编译，生成对应的机器码, 以优化执行效率
```

## 3.13 JS异步编程的方案

### 3.13.1 回调函数

```js
ajax(url, () => {})
将需要在异步任务之后执行的操作作为其参数，当异步任务完成后执行
优点：易理解、易实现
缺点：容易写出回调地狱，不利于维护，各部分高度耦合，每个任务只能指定一个回调函数
```

### 3.13.2 事件监听

```js
事件监听中：异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。

f1.on('done',f2)
f2必须等到f1完成，并给f1绑定一个done事件监听，只有f1发生done事件之后f2才会执行
function f1(){
    setTimeout(() => {
        f1.trigger('done') // 表示执行完成后立即触发done事件
    },1000)
}
优点：比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以"去耦合"（Decoupling），有利于实现模块化。
缺点：整个程序都要变成事件驱动型，运行流程会变得很不清晰。
```

### 3.13.3 发布订阅

```js
事件完全可以理解成信号，如果存在一个信号中心，某个任务执行完成，就向信号中心发布一个信号，其他任务可以向信号中心订阅这个信号，从而知道什么时候自己可以开始执行。这就叫做发布/订阅模式，又称观察者模式。
// 订阅信号
jQuery.subscribe('done', f2);

function f1() {
  setTimeout(function () {
    // ...
    // 向信号中心jQuery发布done信号,从而引发f2的执行
    jQuery.publish('done');
  }, 1000);
}

// 取消订阅
jQuery.unsubscribe('done', f2);

上面代码使用JQuery编写，首先，f2向信号中心jQuery订阅done信号。f1执行完成后，向信号中心jQuery发布done信号，从而引发f2的执行。
以通过查看消息中心，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。s
```

### 3.13.4 Promise

https://www.cnblogs.com/ming1025/p/13092502.html

```js
Promise 实际就是一个对象， 从它可以获得异步操作的消息，Promise 对象有三种状态，pending(进行中)、fulfilled（已成功）和rejected（已失败）。Promise 的状态一旦改变之后，就不会在发生任何变化,将回调函数变成了链式调用。
Promise 的设计思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，用来指定下一步的回调函数。每次调用返回的都是一个新的Promise实例(then可用链式调用的原因)
```

### 3.13.5 Generator/yield

```js
Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）
Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，使用该对象的 next() 方法，可以遍历 Generator 函数内部的每一个状态，直到 return 语句。

Generator 函数的特征:
* function 关键字与函数名之间有一个星号
* 函数体内部使用 yield 表达式，yield 是暂停执行的标记
* next() 方法遇到 yield 表达式，就暂停执行后面的操作,并返回后面的值。

function* gen(x){
    var y = yield x + 2;
    yield x = 5
    return y;
}

var g = gen(1);
console.log(g.next(1)); // {value: 3, done: false}
console.log(g.next(9)); // {value: 5, done: false}
console.log(g.next(9)); // {value: 9, done: true}

上面代码中，第一个 next 方法的 value 属性，返回表达式 x + 2 的值3。第二个next返回的是yield表达式后面的值，即x=5。第三个 next 方法带有参数9，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量 y 接收。因此，这一步的 value 属性，返回的就是9（变量 y 的值）。
```

### 3.13.6 async/await

#### 定义

```js
async 函数就是 Generator 函数的语法糖。MDN定义：async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。
async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。
async function async1() {
  return 2
}
console.log(async1()) // Promise {<resolved>: 2}
上面代码中，函数前面加上 async 就会返回一个 promise 对象。

async function getStockPriceByName(name) {
  const symbol = await getStockSymbol(name);
  const stockPrice = await getStockPrice(symbol);
  return stockPrice;
}
getStockPriceByName('goog').then(function (result) {
  console.log(result);
});

async/await的特征有：
async/await是基于Promise实现的，它不能用于普通的回调函数。
async/await与Promise一样，是非阻塞的。
async/await使得异步代码看起来像同步代码，这正是它的魔力所在。
```

#### 与generator的比较

```js
const fs = require('fs');

const readFile = (fileName) => {
    return new Promise((resolve, reject) => {
        fs.readFile(fileName, (err, data) => {
            if(err) return reject(err)
            resolve(data)
        })
    })
}
// Generator 函数写法
const gen = function* () {
  const f1 = yield readFile('/etc/fstab');
  const f2 = yield readFile('/etc/shells');
  console.log(f1.toString());
  console.log(f2.toString());
};

// aynsc 函数写法
const asyncReadFile = async function () {
  const f1 = await readFile('/etc/fstab');
  const f2 = await readFile('/etc/shells');
  console.log(f1.toString());
  console.log(f2.toString());
};
// 一比较就会发现，async函数就是将Generator函数的星号*替换成async，将yield替换成await，仅此而已。
优点：
1.更好的语义，async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果
2.可以直接执行，不需要next
3.更广的适用性
4.返回值是promise对象，generator返回值是iterator。可以用then进行下一步操作

JS 异步编程发展史：callback -> promise -> generator -> async + await。async/await函数的实现是将Generator函数和自动执行器，包装在一个函数里。它也是目前异步最好的解决方案了。
```

#### await用法

```js
async函数返回一个 Promise 对象。
async函数内部return语句返回的值，会成为then方法回调函数的参数。
async function f() {
  return 'hello world';
}
f().then(v => console.log(v))
// "hello world"
// 上面代码中，函数f内部return命令返回的值，会被then方法回调函数接收到。

// async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。
async function f() {
  throw new Error('出错了');
}

f().then(
  v => console.log('resolve', v),
  e => console.log('reject', e)
)
//reject Error: 出错了
```

```js
正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。

async function f(){
    return await 123
}
f().then(v => console.log(v))

async function f(){
    return await new Promise((res, rej) => {
        res('成功')
    })
}
f().then(r => console.log(r)).catch(e => console.log(e))
// 如果await后面是resolve状态的Promise对象，则必须返回后才能在外部调用f()时用then接收到resolve中的参数，await Promise.resolve()也是一样的
// 如果await后面是reject状态的Promise对象，则不需要返回，外面也能接收到，await Promise.reject()也是一样的
```

```js
当一个await语句后面的Promise对象变为reject状态，那么整个async函数都会停止执行，如果要避免，则需要将该await语句放在try...catch中，或者await Promise.reject('出错').catch(e => console.log(e))
如果多个await命令后的异步操作不存在继发关系，则将其同时触发：
1.let [foo, bar] = await Promise.all([getFoo(), getBar()])
2. let fooPromise = getFoo()
	let barPromise = getBar()
    let foo = await fooPromise
    let bar = await barPromise
```

## 3.14 JS中的各种遍历

```js
1. for
2. forEach()遍历数组
见3.10.3
3. for in 
遍历数组索引、对象属性
let arr = ['111','222','333']
let obj = {name:'txf',age:18,height:'1.88'}
Array.prototype.something = ['原型元素1','原型元素2']
Object.prototype.something2 = {salary: 20}
for(let i in arr){
    console.log(arr[i])
}
for in 会将原型链上的所有属性访问到
解决方法：使用hasOwnProperty()
for(let i in arr){
    if(arr.hasOwnProperty(i)){
        console.log(arr[i])
    }
}
for(let i in obj){
    if(obj.hasOwnProperty(i)){
        console.log(obj[i])
    }
}
// 此时就不会输出原型链上的两个元素了
4. for of 
遍历数组元素值，无法遍历对象
for(let v of arr){
    console.log(i)
}
```

### 对象属性枚举

```js
1. for ... in
// 遍历可枚举属性【包括对象自有以及继承来的】
var obj = {
    'x': 1,
    'y': 2,
    'z': 3
}
obj.propertyIsEnumerable('toString'); // false,不可枚举

for (prop in obj) {
    console.log(prop); // 输出x,y,z；但不会输出toString
}

2. Object.keys()
// 方法会返回一个由给定对象的【所有可枚举自身属性】的属性名组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 
var obj = {
    'x': 1,
    'y': 2,
    'z': 3
}
obj.propertyIsEnumerable('toString');
console.log(Object.keys(obj)); // ["x", "y", "z"]

3. Object.getOwnPropertyNames()
// 方法返回一个由指定对象的【所有自身属性】的属性名【包括不可枚举属性】组成的数组,但【不会获取原型链上的属性】【不包括symbol类型的属性】
// 类数组对象
var obj = { 
    0: "a",
    1: "b",
    2: "c"
};
console.log(Object.getOwnPropertyNames(obj).sort()); // ["0", "1", "2"]

4. Reflect.ownKeys(obj)遍历

返回一个数组,包含对象自身的所有属性,不管属性名是Symbol或字符串,也不管是否可枚举. 
```

## 3.17 JS执行上下文、变量对象、作用域链、this

```
当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)，执行上下文有三种：
1. 全局执行上下文
2. 函数执行上下文
3. eval

执行上下文包含三个生命周期：创建阶段→执行阶段→回收阶段
1.创建阶段

当函数被调用，但未执行任何其内部代码之前，会做以下三件事：
1）创建变量对象(Variable object，VO)：首先初始化函数的参数arguments，提升函数声明和变量声明。后文会详细说明。
2）创建作用域链（Scope Chain）：在执行上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。后文会详细说明。
3）确定this指向：包括多种情况，后文会详细说明。

在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为undefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。
另外，一个函数在被执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过函数执行上下文中会多出this arguments和函数的参数。

2.执行阶段
进入执行上下文、执行代码

3.回收阶段
执行完毕后执行上下文出栈等待垃圾回收
```

## 3.18 JS小技巧

### 声明二维数组

```js
const arr = Array(5).fill(0)
const TArr = arr.map(() => Array(4).fill(0))
// (5) [Array(4), Array(4), Array(4), Array(4), Array(4)]
```

### 求数组中最大、最小、总和

```js
const a = [12,54,5,7,4,12]
a.reduce((prev, cur) => prev + cur)
// 94
a.reduce((prev, cur) => prev > cur ? prev : cur)
// 54
a.reduce((prev, cur) => prev > cur ? cur : prev)
// 4
```

### 数组从小到大、从大到小排序

```js
const array  = [40, 100, 1, 5, 25, 10];

array.sort((a,b) => a-b);
(6) [1, 5, 10, 25, 40, 100]

array.sort((a,b) => b-a);
(6) [100, 40, 25, 10, 5, 1]
```

### 过滤数组中假值

```js 
const array = [3, 0, 6, 7, '', false];
array.filter(Boolean);
// (3) [3, 6, 7]
```

### 计算字符串中字符出现次数

```js
const str = 'hello my name is dadada'

// hash
const hash = {}
for(let char of str) {
    if(char !== ' ') {
        hash[char] = hash[char] + 1 || 1
	}
}
console.log(hash)

// map
const map = new Map()
for(let char of str) {
    if (char === ' ') continue
    if (map.has(char)) {
        map.set(char, map.get(char) + 1)
	} else {
        map.set(char, 1)
    }
}
console.log(map)
```

### 合并对象

```js
const user = { 
 name: 'Kapil Raghuwanshi', 
 gender: 'Male' 
 };
const college = { 
 primary: 'Mani Primary School', 
 secondary: 'Lass Secondary School' 
 };
const skills = { 
 programming: 'Extreme', 
 swimming: 'Average', 
 sleeping: 'Pro',
 name: 'txf!!'
 };

const summary = {...user, ...college, ...skills};
const summary2 = Object.assign(user, college, skills)
```

### 打乱数组

```js
const list = [1,2,3,4,5,6,7,8,9]
list.sort(() => {
    return Math.random() - 0.5
})
```

### 十进制转换为二进制、十六进制

```js
const num = 24
num.toString(2)
num.toString(16)
num.toString(8)
```

### Object遍历属性、属性值、键值对

```js
const obj = {
    a: 1,
    b: 2,
    c: 3
}
Object.entries(obj)
/*
0: (2) ['a', 1]
1: (2) ['b', 2]
2: (2) ['c', 3]
*/
Object.keys(obj)
// (3) ['a', 'b', 'c']
Object.values(obj)
// (3) [1, 2, 3]
```


# 4. Vue.js
## 4.1 Vue生命周期
    见知识总结中的Vue生命周期文件
### 在哪个生命周期内调用异步请求？

```
可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：

能更快获取到服务端数据，减少页面 loading 时间；
ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；

mounted中请求数据有可能出现闪屏等状况
```

### 父组件监听子组件的生命周期方法

```js
比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：
1. 
// Parent.vue
<Child @mounted="doSomething"/>
    
// Child.vue
mounted() {
  this.$emit("mounted");
}
以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：
2. 
//  Parent.vue
<Child @hook:mounted="doSomething" ></Child>

doSomething() {
   console.log('父组件监听到 mounted 钩子函数 ...');
},
    
//  Child.vue
mounted(){
   console.log('子组件触发 mounted 钩子函数 ...');
},    
    
// 以上输出顺序为：
// 子组件触发 mounted 钩子函数 ...
// 父组件监听到 mounted 钩子函数 ...     
```

## 4.2 Vue组件通讯的方法

+ 父子通信：props和this.$emit。props单向数据流，在子组件接收使用但不在子组件修改，而是通过$emit自定义事件传递给父元素来修改

+ 父子组件通信：$parent和$children

+ $ref，获取DOM元素或者组件实例，DOM元素直接this.$refs[refsName]操作元素，组件实例需要this.$refs[refsName].$el操作元素

+ 跨级通信：provide和inject，提供与注入。祖先提供变量，子孙注入后使用。

  + 注意：provide传下去的值并非响应式，要想做到响应式，需要将祖先组件实例this传递（不好用，无用属性过多）。或者使用新API：Vue.observable优化响应式provide（推荐）

  + ```js
    // A.vue
    provide:{
    	for:'test'
    },
    // B.vue
    inject:['for']
    ```

+ 跨级通信：$attrs和$listeners。

  + $attrs不包括props中的属性

  + ```js
    // A.vue
    <B :name="name" :age="age" :sp="sp" @click="AClick"></B>
    method: {
        AClick(){}
    }
    // B.vue
    <C v-bind="$attrs" v-on="$listeners"></C>
    props: ['sp']
    console.log(this.$attrs) // name, age  【没有sp】
    // C.vue
    console.log(this.$attrs) // name, age
    this.$emit('AClick')
    ```

+ 全局通信：eventBus，事件总线。注册bus对象，通过bus.$on分发事件，bus.$emit触发事件。

  + ```js
    bus.$on('globalEvent',(val)=>{
    	this.brothermessage=val;
    })
    bus.$emit('globalEvent',val)
    ```

+ Vuex！

### Vuex和eventBus有什么区别？

```js
使用eventBus:（采用发布订阅模式）
B.$root.bus.$emit('todo')
// 兄弟C也能收到这个消息
C.$root.bus.on('todo',function(){})

使用eventBus的问题：
1. 代码逻辑性极具下降，可阅读性变低（发布订阅没有一个统一的管理位置）
2. 对于每一个action父组件都需要一个on(或dispatch)一个事件来处理
3. 你将很难查找到每一个事件是从哪里触发，满篇都是业务逻辑	

使用vuex有什么优势?
1. 如果在开发过程中保留了所有状态的副本，我们可以像super hero一样如时空穿梭般对代码进行调试，记录每一次状态的变化
2. 你可以构建一个中间件，比如一个日志打印器，在每次用户提交一个action时记录操作，当出现问题时你将会更加容易的调试与fix bug
3. 强制要求你把所有action通过一个store管理，这样团队开发将会更加便捷与明了

什么时候用他们俩？
1. 在某些小型应用上，数据交互并不是很多，比如只有一个登陆状态或者一个购物车状态，那么使用事件总线比较方便
2. 在一些复杂应用中，vuex能够更加方便地管理状态并调试
```

## 4.3 Vue响应式原理

```js
数据劫持 + 观察者模式

Vue2 核心为 Object.defineProperty，Vue3 核心为 Proxy 代理对象

对象内部通过 defineReactive 方法，使用 Object.defineProperty 将属性进行劫持（只会劫持已经存在的属性），数组则是通过重写数组方法（splice，pop等能够响应式修改数组）来实现。

当页面使用对应属性时，每个属性都拥有自己的 dep 属性，存放他所依赖的 watcher（依赖收集），当属性变化后会通知自己对应的 watcher 去更新(派发更新)。

解析：
	Vue通过引入Obeserver类，通过Object.defineProperty对数据的getter、setter进行重写，将数据变为响应式，在getter中收集依赖watcher，setter中更新依赖。在Vue实例化的初始阶段，通过实例化Observer来将数据变为响应式，在真实DOM渲染时实例化Watcher类，创建依赖。而watcher是由Dep管理的，用来收集依赖、派发依赖更新。所以在我们实例化Observer时，调用了defineReactive()函数，其中重写了getter和setter方法，在开始时会实例化一个Dep，在getter中调用dep.depend方法收集依赖，在setter中，如果监听到数据变化，则调用dep.notify()来派发更新。
```

## 4.4 Vue nextTick原理

```js
在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。通过this.$nextTick可以获取最新更新的dom并操作。
Vue实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新，说明 Vue 是异步执行 DOM 更新的。
nextTick新版稳定为微任务，遇到后加入到微任务队列中，因此可以在created中通过nextTick来等待其他生命周期完成后再操作dom，因为vue中的生命周期函数是同步的，nextTick是异步的。

例：
//改变数据
vm.message = 'changed'

//想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新
console.log(vm.$el.textContent) // 并不会得到'changed'

//这样可以，nextTick里面的代码会在DOM更新后执行
Vue.nextTick(function(){
    console.log(vm.$el.textContent) //可以得到'changed'
})
//或者
this.$nextTick(() => {
    console.log(vm.$el.textContent)
})

nextTick的应用场景：需要在视图更新之后，基于新的视图进行操作。
需要注意的是，在 created 和 mounted 阶段，如果需要操作渲染后的试图，也要使用 nextTick 方法。
注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted

应用1：
点击按钮显示原本以 v-show = false 隐藏起来的输入框，并获取焦点。
showsou(){
  this.showit = true
  this.$nextTick(function () {
    // DOM 更新了
    document.getElementById("keywords").focus()
  })
}

应用2：
点击获取元素宽度。
<div id="app">
    <p ref="myWidth" v-if="showMe">{{ message }}</p>
    <button @click="getMyWidth">获取p元素宽度</button>
</div>

getMyWidth() {
    this.showMe = true;
    //this.message = this.$refs.myWidth.offsetWidth;
    //报错 TypeError: this.$refs.myWidth is undefined
    this.$nextTick(()=>{
        //dom元素更新后执行，此时能拿到p元素的属性
        this.message = this.$refs.myWidth.offsetWidth;
  })
}
```

```
深入理解nextTick: https://www.cnblogs.com/hity-tt/p/6729118.html
```

```vue
<template>
    <div>
        <ul>
            <li class="example" v-for="item in list1">{{item}}</li>
        </ul>
        <ul>
            <li class="example" v-for="item in list2">{{item}}</li>
        </ul>
        <ol>
            <li class="example" v-for="item in list3">{{item}}</li>
        </ol>
        <ol>
            <li class="example" v-for="item in list4">{{item}}</li>
        </ol>
        <ol>
            <li class="example" v-for="item in list5">{{item}}</li>
        </ol>
    </div>
</template>
<script type="text/javascript">
export default {
    data() {
        return {
            list1: [],
            list2: [],
            list3: [],
            list4: [],
            list5: []
        }
    },
    created() {
        this.composeList12()
        this.composeList34()
        this.composeList5()
        this.$nextTick(function() {
            // DOM 更新了
            console.log('finished test ' + new Date().toString(),document.querySelectorAll('.example').length)
        })
    },
    methods: {
        composeList12() {
            let me = this
            let count = 10000

            for (let i = 0; i < count; i++) {
                this.$set(me.list1, i, 'I am a 测试信息～～啦啦啦' + i)
            }
            console.log('finished list1 ' + new Date().toString(),document.querySelectorAll('.example').length)

            for (let i = 0; i < count; i++) {
                this.$set(me.list2, i, 'I am a 测试信息～～啦啦啦' + i)
            }
            console.log('finished list2 ' + new Date().toString(),document.querySelectorAll('.example').length)

            this.$nextTick(function() {
                // DOM 更新了
                console.log('finished tick1&2 ' + new Date().toString(),document.querySelectorAll('.example').length)
            })
        },
        composeList34() {
            let me = this
            let count = 10000

            for (let i = 0; i < count; i++) {
                this.$set(me.list3, i, 'I am a 测试信息～～啦啦啦' + i)
            }
            console.log('finished list3 ' + new Date().toString(),document.querySelectorAll('.example').length)

            this.$nextTick(function() {
                // DOM 更新了
                console.log('finished tick3 ' + new Date().toString(),document.querySelectorAll('.example').length)
            })

            setTimeout(me.setTimeout1, 0)
        },
        setTimeout1() {
            let me = this
            let count = 10000

            for (let i = 0; i < count; i++) {
                this.$set(me.list4, i, 'I am a 测试信息～～啦啦啦' + i)
            }
            console.log('finished list4 ' + new Date().toString(),document.querySelectorAll('.example').length)

            me.$nextTick(function() {
                // DOM 更新了
                console.log('finished tick4 ' + new Date().toString(),document.querySelectorAll('.example').length)
            })
        },
        composeList5() {
            let me = this
            let count = 10000

            this.$nextTick(function() {
                // DOM 更新了
                console.log('finished tick5-1 ' + new Date().toString(),document.querySelectorAll('.example').length)
            })

            setTimeout(me.setTimeout2, 0)
        },
        setTimeout2() {
            let me = this
            let count = 10000

            for (let i = 0; i < count; i++) {
                this.$set(me.list5, i, 'I am a 测试信息～～啦啦啦' + i)
            }
            console.log('finished list5 ' + new Date().toString(),document.querySelectorAll('.example').length)

            me.$nextTick(function() {
                // DOM 更新了
                console.log('finished tick5 ' + new Date().toString(),document.querySelectorAll('.example').length)
            })
        }
    }
}
</script>
```



## 4.5 虚拟dom、diff算法、key

### 虚拟dom解释

```
https://www.cnblogs.com/fundebug/p/vue-virtual-dom.html
```

### diff算法

```
Vue的diff算法是基于snabbdom改造过来的，仅在同级的vnode间做diff，递归地进行同级vnode的diff，最终实现整个DOM树的更新。因为跨层级的操作是非常少的，忽略不计，这样时间复杂度就从O(n3)变成O(n)。

diff 算法包括几个步骤：
用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中
当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异
把所记录的差异应用到所构建的真正的DOM树上，视图就更新了
diff的过程就是调用patch函数，就像打补丁一样修改真实dom。所以说key的作用主要是为了高效的更新虚拟DOM。

patch(container,vnode) :初次渲染的时候，将虚拟DOM渲染成真正的DOM然后插入到容器里面。
patch(vnode,newVnode):再次渲染的时候，将新的vnode和旧的vnode相对比，然后之间差异应用到所构建的真正的DOM树上。

```

### key

```
key 是为 Vue 中 vnode 的唯一标记

当我们向同一层的A,B,C,D,E节点中插入一个F时，加入要插到B和C中间，当我们不使用key值时，diff算法见到谁更新谁。旧节点为ABCDE，新节点为ABFCDE，先更新AB，到C时，不清楚C是不是自己，就直接覆盖，变为ABFCD，然后再追加一个E。
如果有key时，到C时，发现C和F不一样就从后面开始判断，发现ED是一样的，就从后面开始更新，最后剩下一个F，创建后插入
```



## 4.6 vue-router路由模式：hash,history,abstract

```
hash模式：
使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器

1.location.hash，它的值就是URL中#后面的东西，特点是：hash虽然出现在URL中，但不会被包含在http请求中，改变hash不会重新加载页面
2.可以给hash的改变添加监听事件：
window.addEventListener('hashchange',funcRef,false)
3.每一次改变hash，都会在浏览器历史中增加一个记录，因此可以实现前端路由“更新视图但不重新请求页面”
4.可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值

特点： 兼容性好但不美观
```

```
history模式：
利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示

1.可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）
2.history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。
特点： 美观但是刷新会出现404，需要后端进行配置
```

```
这两个方法有个共同的特点：当调用他们修改浏览器历史记录栈后，虽然当前 URL 改变了，但浏览器不会刷新页面，这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。
```

```
abstract模式：
支持所有JavaScript运行环境，如Node.js服务器端。如果发现没有浏览器的API，路由会自动强制进入这个模式
```



## 4.7 MVVM

```
MVVM是一种软件架构设计模式，它有三个层：
View层：视图层
在我们前端开发中，通常就是DOM层。主要的作用是给用户展示各种信息。
Model层：数据层
数据可能是我们固定的死数据，更多的是来自我们服务器，从网络上请求下来的数据。
ViewModel层：
视图模型层
视图模型层是View和Model沟通的桥梁。
一方面它实现了Data Binding，也就是数据绑定，将Model的改变实时的反应到View中
另一方面它实现了DOM Listener，也就是DOM监听，当DOM发生一些事件(点击、滚动、touch等)时，可以监听到，并在需要的情况下改变对应的Data。
```

## 4.8 Vue基本指令

### 4.8.1 基本指令

```js
1. "Mustache语法"
{{变量}}
数据是响应式的

2. "v-once"
<tag v-once> | <component v-once>
标签或组件只渲染一次，不会随数据改变而改变

3. "v-html"
<h2 v-html="string">
string: '<a href="http://www.baidu.com">百度</a>'
将string类型的html解析并渲染

4. "v-text == Mustache"

5. "v-pre"
<p v-pre>{{msg}}</p>
跳过该元素及其子元素的编译，显示原本的Mustache语法
```

### 4.8.2 用法较为复杂的指令

#### v-cloak

```
<div v-cloak>
    {{msg}}
</div>
<style>
    [v-cloak]{
        display: none;
    }    
</style>
表示有v-cloak属性的元素不显示，当编译完成后，该属性消失，元素显示
可以用v-cloak解决网页加载缓慢，Vue来不及渲染，页面露出源代码问题，当元素渲染完毕后再展示
```

#### v-bind

```html
<div v-bind:class="active"></div>
<a :href="link"></a>
动态绑定属性，或者向另一个组件传递自定义props值

v-bind绑定class:
"1.对象语法":
"用法一"：直接通过{}绑定一个类
<h2 :class="{'active': isActive}">Hello world</h2>
"用法二"：通过判断传入多个值
<h2 :class="{'active': isActive, 'line': isLine}">Hello world</h2>
"用法三"：和普通的类同时存在，并不冲突
"用法四"：如果过于复杂，可以放在一个methods或者computed中

"2.数组语法":
"用法一"：直接通过[]传入
<h2 :class="['active']">Hello World</h2>
"用法二"：也可以传入多个值
<h2 :class=“[‘active’, 'line']">Hello World</h2>
"用法三"：和普通的类同时存在，并不冲突
"用法四"：如果过于复杂，可以放在一个methods或者computed中

v-bind绑定style:
"1.对象语法":
:style="{color: currentColor, fontSize: fontSize + 'px'}"
:style="styleObj"
styleObj: {
    color: 'red',
    font-size: '15px'
}
"2.数组语法":
<div v-bind:style="[baseStyles, overridingStyles]"></div>
baseStyles: {
    color: 'red',
    font-size: '15px'
}...
```

#### v-on

```html
<button @click="btnClick">点击</button>
<component @click.native="compClick">
参数问题：
情况一：如果该方法不需要额外参数，那么方法后的()可以不添加。
但是注意：如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去
情况二：如果需要同时传入某个参数，同时需要event时，可以通过$event传入事件。
<button @click="btnClick">点击</button>
methods:{
    btnClick(event){
        console.log(event)
    }
}
或者：
<button @click="btnClick(10)">点击</button>
methods:{
    btnClick(item){
        console.log(item) // 10
    }
}
或者：
<button @click="btnClick(10, $event)"></button>
methods:{
	btnClick(count, event){
        console.log(event)
        this.counter += count
    }
}

v-on修饰符(以click为例)
@click.stop：调用event.stopPropagation()
@click.prevent：调用event.preventDefault()
@keyup.13：当事件从特定键触发才会回调
@click.native：监听【组件根元素】的原生事件，一般用于给组件上的监听添加，使得整个组件都能够触发回调，不需要再获取dom元素（ref.$el.offsetTop可以获取组件的DOM元素属性）
@click.once：只触发一次回调
```

#### v-if v-show

```
v-if v-else-if v-else
v-if后面的条件为false时，对应的元素以及其子元素都不会被渲染，没有标签出现在DOM中

v-show
跟v-if差不多，元素会渲染，为false时，给元素设置display:none
当需要频繁切换显示、隐藏时，使用v-show，只切换一次时用v-if
给元素添加key属性，可以保证在渲染时不会重复利用key不同的元素
```

#### v-for(:key="item")

```html
<ul>
    遍历数组
    <li v-for="(item, index) in arr">{{item}}</li>
	遍历对象
    <li v-for="(value, key, index) in obj">{{value}}-{{key}}-{{index}}</li>
</ul>
我们在使用v-for时，推荐给对应元素或组件添加一个:key属性，来高效地更新虚拟DOM，这是因为Vue的虚拟DOM的Diff算法
Diff算法会逐层比较更新前后元素的变化，当我们要在某一层插入新节点或者删除时，比如ABCDEF代表了几个节点，我们要在C和D中间插个G，Diff算法默认会将D修改为G，E修改为D，F修改为E，最后再插入F；当要删除D时，将D修改为E，将E修改为F，最后的F再删除
如果我们给每个元素添加一个:key标识，Diff算法就可以正确的识别节点，找到对应位置插入节点，通常:key="item"，而不是:key="index"，因为如果绑定了index，那么在操作元素时，大部分元素的index也会发生改变，跟没有绑定没区别，所以一般绑定值，而不是绑定索引

响应式的数组方法(会修改原数组的方法)
push(),pop(),shift(),unshift(),splice(),sort(),reverse()
```

#### v-model

```html
表单元素和数据双向绑定
<input type="text" v-model="msg">
<h2>{{msg}}</h2>
输入和显示是响应式同步的

原理：
v-model其实是个语法糖，本质为：
1.v-bind绑定一个value属性
2.v-on指令给当前元素绑定input事件
<input type="text" v-model="message">
等同于
<input type="text" v-bind:value="message" v-on:input="message = $event.target.value">

修饰符：
lazy:
<input type="text" v-model.lazy="msg">
当数据在失去焦点或者回车时才会更新
number:
让输入框中的内容自动转换为number类型
trim:
去除输入的首位空格
```

## 4.9 组件化开发

### 思想和基础知识

```
将一个页面拆分成各种功能小模块封装起来，并且将它们联系起来。
组件化提供了一种抽象，让我们可以开发出一个个可复用的独立组件来构建应用
使用组件需要在你需要使用的组件中注册，注册之后可以通过相应的标签在模板中使用，组件一般命名为DetailShopInfo这类的，使用时<detail-shop-info>
```

```
通过Vue.component()注册的是全局组件，该组件可以在任何Vue实例下使用，如果挂在在某个实例中，就是局部组件，无法在实例外使用

在别的组件中注册的组件称为子组件与父组件
```

```
组件无法直接访问Vue实例的数据，因此每个组件需要保存自己需要用到的数据，包括父子通信、兄弟通信的数据，都需要自我保存在data中，而组件的data属性必须为一个函数，返回一个对象:
data(){
	return {
		msg: 'aaa'
	}
}
因为组件为了保证复用，它的数据在每一次使用组件时都必须得是原始、并被操作过的，这样同一个组件在多次使用时的数据不会共用，互不影响
```

### 组件通信

```
见4.2

父传子：props
父：
<child-comp :name="name">
子：
props:{
    name: {
        type: String,
        default(){
        return ''
        }
    }
}

子传父：自定义事件
父：
<child-comp @item-click="changeState">
item-click是子组件$emit过来的，changeState是父组件在methods中定义的
子：
<button @click="btnClick(item)" v-for="(item, index) in arr">
methods:{
	btnClick(item){
		this.$emit('item-click',item)
	}
}
```

### slot

~~~html
组件中使用slot，让使用者决定组件内部内容显示什么，比如导航栏，封装成一个可复用组件nav-bar，它的内容是不同的，因此我们可以给tab-bar设置一个插槽，由用户来决定插入多少个nav-bar-item，然后在nav-bar-item中再设置插槽，由用户来决定每一个小块显示哪些内容

使用：
父组件：
<div>
	<slot></slot>
</div>
子组件：
````
使用时:
<parent>
	<child>
	<child>
	<child>
</parent>
具名插槽：
设置插槽时：
<slot name="left">我是左侧</slot>
<slot name="center">我是中间</slot>
填充时：
<span slot="left">lt;</span>
即将该元素替换对应的left插槽
~~~

## 4.10 Objectr.defineProperty实现双向绑定

### 双向绑定的基本思路

```
1. 要做到双向绑定，即在我们修改数据时，视图发生变化，而在视图发生变化时，我们要去修改其对应的数据，而视图的变化，相对简单，因为我们可以使用各种监听事件，当事件被触发时，我们就去修改相应的数据，这里可以使用发布-订阅的设计模式来实现。
2. 而数据的变化，相对来说就难以去监听了，因为数据没有所谓的事件，所以我们要去采用别的方式，这个方式就是数据劫持，当我们访问或修改对象的属性时，就会触发相应的事件。事实上就是劫持set和get操作，当数据发生变化时触发事件
3. 所以实现双向绑定的基本思路就是发布-订阅+数据劫持
```

### Object.defineProperty监听操作

```js
Object.defineProperty监听对象的get和set操作：
let obj = {
    a: 1
}
let val = 1
let newVal = 2
Object.defineProperty(obj, "a", {
    get(){
        console.log('数据被获取')
        return val
    },
    set(){
        console.log('数据被修改')
        val = newVal
    }
})
// 这样每当我们获取obj的a属性或者设置修改a属性的时候，都会被劫持并打印出相应的内容，而在vue2.x中正是采用这种监听方式
// 使用发布-订阅模式，data上的数据即是发布方，而视图的修改是订阅方，每当数据发生修改时，就会发布信息，而订阅方接受到相应的信息，就会对视图进行修改，这样就达到了数据修改时改变视图的目的
```



```
Vue 主要通过以下 4 个步骤来实现数据双向绑定的：
实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。
实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。
实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。
实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。
```



## 4.11 webpack

```
模块化打包工具，帮助项目开发进行模块化管理，处理各个模块间的依赖，并且具有打包功能

loader是webpack中的文件转换工具，webpack本身只支持转换js和json，因此在打包时需要转换一些特殊文件(css,img...)，此时就需要用到loader，比如：
css-loader,style-loader,file-loader,babel-loader...

loader的使用过程：
* npm安装loader
* 在webpack.config.js中的module的rules下配置
module.exports = {
	entry: 'main.js',
	output:{},
	module:{
        rules: [
            {
                test: /\.css$/,
                use: ['css-loader']
            },
            {
                ...
            }
        ]
    }
}



plugin是插件，是webpack功能的扩展，可以实现loader无法实现的功能，比如用于优化打包、压缩、重新定义环境变量等，比如
uglify-webpack-plugin,HtmlWebpackPlugin

plugin的使用过程：
* 通过npm安装需要使用的plugins
* 在webpack.config.js中的plugins中配置插件

module.exports = {
	entry: '',
	output:{},
	module:{ rulese: [{},{}...]},
	plugins: [
        new webpack.BannerPlugin('版权...'),
        new HtmlWebpackPlugin({
        template: 'index.html'
        })
    ]
}
```

## 4.12 路由 vue-router

### 4.12.1 路由&路由发展阶段

```
路由，其实就是指向的意思，当我点击页面上的home按钮时，页面中就要显示home的内容，如果点击页面上的about 按钮，页面中就要显示about 的内容，也可以说是一种映射。

路由发展阶段：
1.后端路由阶段：
HTML页面由后端渲染后返回
优点：浏览器不需要加载css和js，有利于SEO优化
缺点：HTML代码和数据以及逻辑混在一起，前后端并未分离
2.前后端分离阶段：
前端通过ajax获取数据，后端提供接口。
优点：前后端分离，前端注重交互和页面，后端注重数据，移动端能够使用相同的后端接口
3.单页面富应用阶段（SPA）：
在前后端分离阶段加入了前端路由。
前端路由的核心：
改变URL，但页面不进行整体刷新
```

#### SPA单页面应用

```
SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。

优点：
用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
基于上面一点，SPA 相对对服务器压力小；
前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

缺点：
初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。
```



### 4.12.2 前端路由的规则

```
URL的hash模式
URL的hash也就是锚点(#), 本质上是改变window.location的href属性.
我们可以通过直接赋值location.hash来改变href, 但是页面不发生刷新

HTML5的history模式

可以在router的index.js中： 
const router = new Router({
	routes,
	mode: 'history'/'hash(默认)'
})
```

### 4.12.3 vue-router

```
vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。
vue-router是基于路由和组件的，路由用来设定访问路径，将路径和组件映射起来。在vue-router的单页面应用中，页面路径的改变即组件的切换。
```

#### 安装

```js
vue-router的安装：
1. 需要在router文件的入口文件index.js中：
import Router from 'vue-rotuer'
2. 懒加载组件:
在组件被访问到时，才加载
const Home = () => import('...Home.vue')
const Detail = () => import('...Detail.vue')
3. Vue.use(Router)
4. 创建路由实例并导出: 
const routes = [
    {
        path: '',
        redirect: '/home'
    },
    {
        path: '/home',
        component: Home,
        meta: {
            footShow: true 
            // 用来在App.vue中判断是否在该页面中显示底部main-tab-bar
            // <main-tab-bar v-if="$route.meta.footShow" />
        }
    }
]
const router = new Router({
    routes,
    mode: 'history'
})
export default router
5. 在项目的入口文件main.js中把router挂在到Vue实例上:
import router from '...router(/index.js)'
new Vue({
    render: h => h(App),
    router,
    store
}).$mount('#app')
```

#### 使用

```
1. 创建对应的路由组件
2. 配置路由映射（组件和路径的映射关系）
3. 使用路由：在App.vue中，通过<router-link>和<router-view>
<router-view>：根据当前路径，动态渲染组件代替它本身，路由切换时也只会切换<router-view>挂载的组件
```

#### 路由代码跳转

```js
通过JS：
比如点击了tab-bar-item会进行路由跳转，则需要在其中设置点击事件：
itemClick(){
	this.$router.push('/location').catch(err => {console.log(err)})
    // 这一步是为了防止连续点击报错
	this.$router.replace(this.path)
    // 这里的path，是从其父组件main-tab-bar中传入的
    // 传入的是固定的数据： <tab-bar-item path="/home">
}
```

#### 动态路由

```
有时候路径并不确定，比如不同用户进入个人中心时，URL上带有自己的id。
需要在router中配置：
{
	path: '/detail/:id',
	component: User
}
在使用时：
methods:{
	itemClick(){
		this.$router.push('/detail'+this.goodsItem.iid)
	}
}
```

#### 嵌套路由

```js
实现嵌套路由有两个步骤:
1. 创建对应的子组件, 并且在路由映射中配置对应的子路由.
比如需要访问/home/news 和 /home/message
在router中设置：
{
	path: '/home',
	component: Home,
	children: [
		{
			path:'/news',
			component: News
		},
		{
			path:'/message',
			component: Message
		}
	]
}
2. 在组件内部使用<router-view>标签以及路由路径
```

#### 传参方式

```js
1. params的类型:
//$router : 是路由操作对象，只写对象
//$route : 路由信息对象，只读对象

//操作 路由跳转
this.$router.push({
    name:'hello',
    params:{
        name:'word',
        age:'11'
    }
})

//读取 路由参数接收
this.name = this.$route.params.name;
this.age = this.$route.params.age;

2. query的类型:
//query传参，使用path跳转
this.$router.push({
    path:'second',
    query: {
        queryId:'20180822',
        queryName: 'query'
    }
})

//query传参接收
this.queryName = this.$route.query.queryName;
this.queryId = this.$route.query.queryId;
```

#### 两种传参方式的区别

```
* 在配置的时候params用的是name、query用的是path
* 接收参数的时候，是route而不是router了！
* query更加类似于我们ajax中get传参，参数拼接到了URL中。
* params则类似于post，参数是默认传递
```

####  $router和$route

```
$router为Ruter的实例，想要导航到不同URL，则使用this.$router.push方法
$route为当前router活跃对象，里面可以获取name,path,query,params等
// 所有的组件都继承自Vue类的原型
// $router和$route都是来自Vue的原型，因此所有组件都能使用this.$router | this.$route
```

#### 导航守卫

```js
vue-router提供的导航守卫主要用来监听路由的进入和离开的.
vue-router提供了beforeEach和afterEach的钩子函数, 它们会在路由即将改变前和改变后触发.

我们可以利用beforeEach来完成网页标题的修改
1. 在对应路由下设置meta属性，添加title
const routes = [
	{
		path: '/home',
		component: Home,
		children:[],
		meta: {
			title: '首页'
		}
	}
]
2. 利用导航守卫，修改标题
在router中：
router.beforeEach((to, from, next) => {
	window.document.title = to.meta.title
	next()
})
// 这里我们使用的导航守卫, 被称之为全局守卫.

导航钩子的三个参数：
* to：即将要进入的目标的路由对象（routes中的某一对象）
* from：当前导航即将要离开的路由对象
* next：调用该方法后，才能进入下一个钩子

* 如果是后置钩子, 也就是afterEach, 不需要主动调用next()函数.
// 还有路由独享的守卫、组件内的守卫

路由独享的守卫：（beforeEnter）
{
    path: '/foo',
    component: Foo,
    beforeEnter((to, from, next) => {...})
}

组件内的守卫：（beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave）
组件中：
beforeRouteEnter(to, from, next){
	// 无法获取组件实例this
    // 当守卫执行前，组件实例未被创建
}，
beforeRouteUpdate(to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
},
beforeRouteLeave(to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
}
```

##### 导航流程

```
1.导航被触发。
2.在失活的组件里调用 beforeRouteLeave 守卫。
3.调用全局的 beforeEach 守卫。
4.在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
5.在路由配置里调用 beforeEnter。
6.解析异步路由组件。
7.在被激活的组件里调用 beforeRouteEnter。
8.调用全局的 beforeResolve 守卫 (2.5+)。
9.导航被确认。
10.调用全局的 afterEach 钩子。
11.触发 DOM 更新。
12.调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。
```

#### keep-alive

```html
keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。一般结合路由和动态组件一起使用，用于缓存组件。
它们有两个非常重要的属性:
include - 字符串或正则表达，只有匹配的组件会被缓存
exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存
* 匹配的是路由的name

router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存：
<keep-alive exclude="Detail">
	<router-view>
    </router-view>
</keep-alive>

当组件被缓存并且切换时，它的created钩子不会被调用，因为它已被缓存，没有重新创建，因此：
keep-alive对应两个钩子函数 activated 和 deactivated ，当组件被激活时（代替created），触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。

除了这种缓存方式，也可以使用路由的元信息，对多个router-view使用v-if
<keep-alive>
<!-- 缓存的页面 -->
   <router-view v-if="$route.meta.keepAlive"></router-view>
</keep-alive>
<router-view v-if="!$route.meta.keepAlive"></router-view>
<!-- 不缓存的页面 -->
```



## 4.13 computed和watch

```
computed：
1. 在 computed 中定义的每一个计算属性（可以直接在computed中定义）都会被缓存起来，只有当计算属性里面依赖的一个或多个属性变化了，才会重新计算当前计算属性的值，如果没有变化，那么就会使用缓存的值。
2. 一个计算属性依赖一个或多个data或者props中的数据，一旦其中一个变化了，将会重新计算新值。
3. 不支持异步。
4. 多个数据的变化影响一个计算属性的变化

watch：
1. watch 是属性监听器，一般用来监听属性的变化（也可以用来监听计算属性函数），并做一些逻辑。
2. 监听某个属性变化，变化之后对某些属性进行一些操作
3. 支持异步
4. 一个数据的变化可能会影响多个数据的变化

* 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；
computed:{
	fullName(){
		return this.firstName + ' ' + this.lastName
	}
}
* 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch
watch: {
	a(newVal, oldVal){
		setTimeout(() => {
			if(newVal < 3){
				this.msg = '太短'
				return
			}
			if(newVal > 5){
				this.msg = '太长'
				return
			}
			this.msg = ''
		}, 1000)
	}
}
```

## 4.14 父子组件的生命周期执行顺序

```
加载渲染过程：
父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted
更新过程：
父beforeUpdate->子beforeUpdate->子updated->父updated
销毁过程：
父beforeDestroy->子beforeDestroy->子destroyed->父destroyed
```

## 4.15 Vuex

```
Vuex（插件） 是一个专为 Vue.js 应用程序开发的状态管理模式。
可以简单的将其看成把需要多个组件共享的变量全部存储在一个对象里。将这个对象放在顶层的Vue实例中，让其他组件可以使用。
Vuex的核心就是store，它是一个对象，用来保存“状态”，其中有state,mutations,actions,getters，state即需要共享的变量，这个对象中的数据是响应式的，修改它的唯一方法就是通过mutations，这是因为Vuex可以更明确的追踪状态的变化，所以不要直接改变store.state的值。如果有异步操作，则需要在actions中，commit mutations中的操作state的方法，并传入负载参数。
```

### Vuex与localStorage/sessionStorage的区别

```
1. vuex中的数据存储在内存，localStorage存储在本地，sessionStorage存储在会话页面
2. vuex用于组件间传值，localStorage和seesionStorage主要用于不同页面之间传值
3. 页面刷新时（清除了内存），vuex存储的数据丢失，localStorage不会，页面关闭时sessionStorage数据消失
4. vuex可以做到响应式，另外两个不行
```

### 使用Vuex

```js
1. npm全局安装vuex
2. src中创建一个文件夹store，文件中创建入口文件index.js，actions.js，mutations.js，getters.js
3. 在index.js中：
import Vuex from 'vuex'
import Vue from 'vue'
import mutations from './mutations'
import actions from './actions'
import getters from './getters'
Vue.use(Vuex) // 使用插件
const state = {
    cartList: []
}
const store = new Vuex.Store({
    state,
    mutations,
    actions,
    getters
})
export default store
4. 挂载到Vue实例上，在Vue项目的入口main.js中：
import store from './store/index'
new Vue({
    render: h=>h(App),
    router,
    store
}).$mount('#app')
5. 通过this.$store.state.属性的方式来访问状态
6. 通过this.$store.commit('mutation中方法')来修改状态
```

### state

```
单一状态树，能够让我们最直接的方式找到某个状态的片段，而且在之后的维护和调试过程中，也可以非常方便的管理和维护。
定义了应用状态的数据结构，可以在这里设置默认的初始状态。
```

### getters

```js
允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。
在getter中处理state中的数据：
export default{
	cartLength(state){
		return state.cartList.length
	},
    cartList(state){
        return state.cartList
    }
}
可以在组件中通过:
import {mapGetters} from 'vuex'
computed:{
    ...mapGetters(['cartLength'])
}
直接能够使用处理过后的状态
```

### mutations

```js
是唯一更改 store 中状态的方法，且必须是同步函数。
通过commit提交
export default{
    addCounter(state, payload){
        payload.count++
	},
    addToCart(state, payload){
        payload.checked = true
        state.cartList.push(payload)
    }
    // payload就是传入的多个参数
}
如果要同步修改state时，可以在组件中直接:
this.$store.commit('addCounter')
this.$store.commit('addToCart', product)
或者：
this.$store.commit({
    type: 'changeCount',
    count: 100
})

当给state中的对象添加新属性时：	
不能这样：
state.info['height'] = payload.height
而要遵守Vuex的规则：
1. Vue.set(state.info, 'height', payload.height)
2. state.info = {...state.info, 'height': payload.height}
```

### actions

```js
用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。
actions.js中：
export default{
    addCart(context, payload){
        return new Promise((resolve, reject) => {
            ...
            if(...){
                context.commit('addCounter', oldProduct) 
                resolve('商品数量+1')
            }else{
                payload.count = 1
                context.commit('addToCart', payload)
                resolve('添加商品成功')
            }
        })
	}
}
// context是和store对象具有相同方法和属性的对象.
// 也就是说, 我们可以通过context去进行commit相关的操作, 也可以获取context.state等.

组件中使用时：
import {mapActions} from 'vuex'
methods: {
    ...mapActions(['addCart'])
}
addToCart(){
    const product = {}
    product.iid = this.iid
    ...
    this.addCart(product).then(res => {})
    // 或者没有使用mapActions的话:
    // this.$store.dispatch('addCart').then(res => {})
}
```

### module

```
允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。
```

### Vuex 的底层原理

```
State：提供一个响应式数据
Getter：借助Vue的计算属性computed来实现缓存
Mutation：更改state方法
Action：触发mutation方法
Module：Vue.set动态添加state到响应式数据中   
```

### Vuex跟普通的全局对象有什么区别？

```
1. Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
2. 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。
```

### 如何处理表单绑定的状态？

```js
当在严格模式中使用 Vuex 时，在属于 Vuex 的 state 上使用 v-model 会比较棘手：
<input v-model="obj.message">
假设这里的 obj 是在计算属性中返回的一个属于 Vuex store 的对象，在用户输入时，v-model 会试图直接修改 obj.message。在严格模式中，由于这个修改不是在 mutation 函数中执行的, 这里会抛出一个错误。

用“Vuex 的思维”去解决这个问题的方法是：给 <input> 中绑定 value，然后侦听 input 或者 change 事件，在事件回调中调用一个方法:
<input :value="message" @input="updateMessage">
// ...
computed: {
  ...mapState({
    message: state => state.obj.message
  })
},
methods: {
  updateMessage (e) {
    this.$store.commit('updateMessage', e.target.value)
  }
}
下面是 mutation 函数：

// ...
mutations: {
  updateMessage (state, message) {
    state.obj.message = message
  }
}
#双向绑定的计算属性
必须承认，这样做比简单地使用“v-model + 局部状态”要啰嗦得多，并且也损失了一些 v-model 中很有用的特性。另一个方法是使用带有 setter 的双向绑定计算属性：

<input v-model="message">
// ...
computed: {
  message: {
    get () {
      return this.$store.state.obj.message
    },
    set (value) {
      this.$store.commit('updateMessage', value)
    }
  }
}
```

## 4.17 Vue3 与 Vue2的对比

### 4.17.1 Proxy代理对象

#### 为什么要用Proxy代替Object.defineProperty?

```
Object.defineProperty只能一个属性一个属性地监听，，也就是说，对于data对象，我们需要进行深度遍历，去监听每一个属性的变化，而一旦我们对data一个比较深的对象直接修改它的值，那么就又得对其进行重新地遍历，非常损耗性能
反观proxy，proxy可以监听一整个对象，且基于proxy的监听，只有当一个数据被用到的时候，才会去监听它，所以就避免了上面提及的问题，在监听上大大降低了性能的消耗
```

#### Proxy和Object.defineProperty各自的优势

```
Proxy 的优势如下:
* Proxy 可以直接监听对象而非属性；
* Proxy 可以直接监听数组的变化；
* Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；
* Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；
* Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；

Object.defineProperty 的优势如下:
* 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。
```

### 4.17.2 性能提升

```
1. diff算法优化
2. 事件侦听器缓存
3. ssr渲染
```

### 4.17.3 代码体积

```
打包大小减少41%。
vue3使用 tree-shaking。

Tree Shaking 摇树优化，指的就是当我们引入一个模块的时候，不引入这个模块的所有代码，只引入我们需要的代码。

在 vue2 中，很多函数都挂载到全局 Vue 对象上，如：nextTick、set 函数等，虽然我们不常用，但打包时只要引入 Vue 这些全局函数会打包进 bundle 中。而 vue3 中，引入tree-shaking，所有的 API 都通过 ES6 模块化的方式引入，这样就能够让 webpack 或 rollup 等打包工具在打包时，就会自动对没有用到的 API 进行剔除，最小化 bundle 体积。

初次渲染快55%, 更新渲染快133%。组件选择了按需引入，使得打包后的体积也更小了，所以项目运行的时候速度更快，更顺畅了！
```

### 4.17.4 编译被优化

```
1. 静态提升
在 vue2 中，无论元素是否参与更新，每次都会重新创建然后再渲染。
vue3 使用静态提升后，对于不参与更新的元素，只会被创建一次，在渲染时直接复用就好了。

2. Fragment
模板内不用再创建一个唯一根节点，可以直接放同级标签和内容。就相当于少了一个节点嵌套渲染。
```

### 4.17.5 选项式API vs 组合式API

```
1. vue3 的组合式 api 相对来说，更有利于维护和封装。
2. 组合式 api 高内聚，低耦合。

在 vue2 中采用选项式 api ，会在 vue 文件的 data、methods、watch、computed 中定义属性和方法，共同处理页面逻辑，多个功能相互交叉，缠绕在一起，代码过于分散。

而 vue3 新增了组合式 api ，一个功能模块代码会集中到一起，实现高内聚，低耦合。提高代码的可读性和可维护性，基于函数组合的 api 更好地重用逻辑代码。

vue3 中用 setup 函数代替了 vue2 中的 beforeCreate 和 created 。
```

### 4.17.6 更好的支持TS

```
Vue3处理逻辑、声明变量都集中在一起，使用ref、reactive，不再是option API中简单的data初始化，能更好的使用TS进行数据类型限制、接口、类、参数类型限制等
```

### 4.17.7 新组件

```
1. fragment
不需要根节点，多个元素或标签可并列存在。
2. teleport
可以把 teleport 中的内容添加到任意的节点内，对于嵌套较深的组件来说绝对是一个福音。
3. supense
允许程序在等待异步组件渲染一些后备的内容，可以让我们创建一个平滑的用户体验。
```



## 4.18 直接给数组赋值，Vue能检测到吗

```
1. vm.items[indexOfItem] = newValue
2. vm.items.length = newLength
上面直接修改的两种情况都无法被检测到

对于操作数组元素，需要使用方法：
1. Vue.set(items, indexOfItem, newValue)
2. vm.$set
3. vm.items.splice(indexOfItem, 1, newValue)
对于操作数组长度，需要使用方法：
vm.items.splice(newLength)
```

### vm.$set源码分析

```js
export function set (target: Array<any> | Object, key: any, val: any): any {
  // target 为数组  
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    // 修改数组的长度, 避免索引>数组长度导致splcie()执行有误
    target.length = Math.max(target.length, key)
    // 利用数组的splice变异方法触发响应式  
    target.splice(key, 1, val)
    return val
  }
  // key 已经存在，直接修改属性值  
  if (key in target && !(key in Object.prototype)) {
    target[key] = val
    return val
  }
  const ob = (target: any).__ob__
  // target 本身就不是响应式数据, 直接赋值
  if (!ob) {
    target[key] = val
    return val
  }
  // 对属性进行响应式处理
  defineReactive(ob.value, key, val)
  ob.dep.notify()
  return val
}

* 如果目标是数组，直接使用数组的 splice 方法触发响应式；
* 如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用   defineReactive 方法进行响应式处理（ defineReactive 方法就是  Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）
```



## 4.19 Vue中的proxy代理

```
跨域解决方案：
jsonp
cors
Node中间件代理(两次跨域)
nginx反向代理
--------------------------------------------------------------------------
CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案
JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。
不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。
日常工作中，用得比较多的跨域方案是cors和nginx反向代理。
```

### 4.19.1 proxy代理原理及核心配置

#### 原理

```
vue 中的 proxy 就是利用了 Node 代理，原理还是因为服务器端没有跨域这一说嘛，也是用了这么一个插件http-proxy-middleware
```

#### 核心配置

```js
1. 你要 http://e.dxy.net/api/test 你可以在本地调 localhost:8080/api/test，如axios.get('/api/test')
localhost:8080/api/test -> http://e.dxy.net/api/test
localhost:8080/bcma/api/test -> http://e.dxy.net/bcma/api/test

//vue-cli3.0 里面的 vue.config.js做配置
devServer: {
  proxy: {
      '/api': {
          target: 'http://e.dxy.net',  // 后台接口域名
          ws: true,        //如果要代理 websockets，配置这个参数
          secure: false,  // 如果是https接口，需要配置这个参数
          changeOrigin: true,  //是否跨域
      }
  }
}

2. 当你调接口后端的命名没有统一给接口前加 /api 这类的标识，那么你可以自己加，也就是你可以在本地调 localhost:8080/api/test，
如axios.get('/api/test')，而你要的目标接口是 http://e.dxy.net/test，你就可以用 pathRewrite，遇到 /api 就去找代理 http://e.dxy.net 并且把 /api 重写为 /

//vue-cli3.0 里面的 vue.config.js做配置
devServer: {
  proxy: {
      '/api': {
          target: 'http://e.dxy.net',  // 后台接口域名
          ws: true,        //如果要代理 websockets，配置这个参数
          secure: false,  // 如果是https接口，需要配置这个参数
          changeOrigin: true,  //是否跨域
          pathRewrite:{
              '^/api': '/'
          }
      }
  }
}

3. 这个是对所有的接口都代理的，不止是检测到 /api 的接口，比如：
localhost:8080/api/test -> http://e.dxy.net/api/test
localhost:8080/test -> http://e.dxy.net/test

devServer: {
 proxy: 'http://e.dxy.net'
}
```

## 4.20 provide 和 inject0

```js
provide和inject是祖先和后代组件通信的方式，provide在祖先组件中注入，inject 在需要使用的地方引入即可。

provide
选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的property。
inject
可以是一个字符串数组、也可以是一个对象。

我们可以把依赖注入看做一部分大范围的prop，只不过它具有以下特点：
1. 祖先组件不需要知道哪些后代组件使用它提供的属性
2. 后代组件不需要知道被注入的属性是来自哪里
注意： provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。
可以给在inject中给变量重命名，name1: {from: 'name',default:()=>{} }
Parent.vue: 
data(){
  return {
    nameObj: {
      name: 'txf'
    },
    age: 12,
    city: '深圳'
  }
},
provide(){
  return {     
    nameObj: this.nameObj,
    age: 12,
    cityFn: () => this.city
  }
}

Children.vue:
inject: ['nameObj', 'age', 'cityFn'],
computed: {
  city(){
    return this.cityFn()
  }
}

当我们改变祖先组件中的data时，后代组件不会响应式改变
```



# 5. ES6

## 5.1 ES6新特性

```
1. const let 
* let 声明变量可以重新赋值，但不能在同一作用域重新声明
* const声明变量必须初始化，但不能再同一作用域重新声明或重新赋值，const 指针指向的地址不可以变化，指向地址的内容可以变化，因此const定义的对象数组中的元素都可以修改、删除、增加。
* 两者都为块级作用域

let、const声明的变量只能在块级作用域中使用，没有变量提升，不能重复声明，必须先声明再使用。const声明变量必须伴随初始化，且const声明的变量值不可以修改。

var声明的变量作用域是整个封闭函数，是全局的（浏览器环境下会挂到window上，作为window的属性，let、const不会），var声明的变量存在变量提升，声明会提升到作用域的最顶部。var可以重复声明。
```

```
2. 模板字符串``
字符串拼接，如：
`我的名字是${name}，我今年${age}岁了`
name和age都是变量
```

```js
3. 解构赋值
const List = ['1','2','3','4']
const [a,b,c,d] = List
console.log(a); // 1

const person = {
  name: 'txf',
  age: 18
}
const {name,age} = person
console.log(name, age); // txf 18

对于对象的深层解构赋值：
const data = {
    token: 'dzf87vxcvr87234dvcz',
    userInfo: {
        id: '001',
        name: 'txf',
        age: 22,
        salary: 20
    }
}
const {token, userInfo: {id: userId, name: userName}} = data
console.log(token, userId, userName)
```

```js
4. 函数参数默认值
function debounce(func, delay=1000){
  let timer = null
    return function(...args){
      if(timer){
        clearTimeout(timer)
      }
      timer = setTimeout(() => {
          func.apply(this, args)
      }, delay);
    }
}
function throttle(func, delay){
  let timer = null
  return function(...args){
    if(!timer){
      timer = setTimeout(() => {
        func.apply(this, args)
        timer = null
      }, delay);
    }
  }
}
```

```js
5. 扩展运算符
let arr = [1,2,3]
console.log(...arr) // 1 2 3 
```

```
6. 箭头函数
以下场景不能使用箭头函数：1.对象方法 2.构造函数 3.事件回调
let fn = () => {}
```

```
7. for of
```

```
8. class类
```

```
9. 模块化import export
```

```
10. promise
```

```
11. async/await(ES7)
```

```
12. Symbol
```

```
13. Set Map
```

## 5.2 axios

```
Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。

主要特点:
在浏览器中发送XMLHttpRequests请求
在node.js中发送http请求
支持Promise API
拦截请求和响应
转换请求和响应数据
取消请求
自动转换JSON数据
客户端支持防御XSRF
```

### 请求配置

```js
这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。

{
   // `url` 是用于请求的服务器 URL
  url: '/user',

  // `method` 是创建请求时使用的方法
  method: 'get', // default

  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。
  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL
  baseURL: 'https://some-domain.com/api/',

  // `transformRequest` 允许在向服务器发送前，修改请求数据
  // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法
  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream
  transformRequest: [function (data, headers) {
    // 对 data 进行任意转换处理
    return data;
  }],

  // `transformResponse` 在传递给 then/catch 前，允许修改响应数据
  transformResponse: [function (data) {
    // 对 data 进行任意转换处理
    return data;
  }],

  // `headers` 是即将被发送的自定义请求头
  headers: {'X-Requested-With': 'XMLHttpRequest'},

  // `params` 是即将与请求一起发送的 URL 参数
  // 必须是一个无格式对象(plain object)或 URLSearchParams 对象
  params: {
    ID: 12345
  },

   // `paramsSerializer` 是一个负责 `params` 序列化的函数
  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)
  paramsSerializer: function(params) {
    return Qs.stringify(params, {arrayFormat: 'brackets'})
  },

  // `data` 是作为请求主体被发送的数据
  // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH'
  // 在没有设置 `transformRequest` 时，必须是以下类型之一：
  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams
  // - 浏览器专属：FormData, File, Blob
  // - Node 专属： Stream
  data: {
    firstName: 'Fred'
  },

  // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)
  // 如果请求话费了超过 `timeout` 的时间，请求将被中断
  timeout: 1000,

   // `withCredentials` 表示跨域请求时是否需要使用凭证
  withCredentials: false, // default

  // `adapter` 允许自定义处理请求，以使测试更轻松
  // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).
  adapter: function (config) {
    /* ... */
  },

 // `auth` 表示应该使用 HTTP 基础验证，并提供凭据
  // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头
  auth: {
    username: 'janedoe',
    password: 's00pers3cret'
  },

   // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'
  responseType: 'json', // default

  // `responseEncoding` indicates encoding to use for decoding responses
  // Note: Ignored for `responseType` of 'stream' or client-side requests
  responseEncoding: 'utf8', // default

   // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称
  xsrfCookieName: 'XSRF-TOKEN', // default

  // `xsrfHeaderName` is the name of the http header that carries the xsrf token value
  xsrfHeaderName: 'X-XSRF-TOKEN', // default

   // `onUploadProgress` 允许为上传处理进度事件
  onUploadProgress: function (progressEvent) {
    // Do whatever you want with the native progress event
  },

  // `onDownloadProgress` 允许为下载处理进度事件
  onDownloadProgress: function (progressEvent) {
    // 对原生进度事件的处理
  },

   // `maxContentLength` 定义允许的响应内容的最大尺寸
  maxContentLength: 2000,

  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte
  validateStatus: function (status) {
    return status >= 200 && status < 300; // default
  },

  // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目
  // 如果设置为0，将不会 follow 任何重定向
  maxRedirects: 5, // default

  // `socketPath` defines a UNIX Socket to be used in node.js.
  // e.g. '/var/run/docker.sock' to send requests to the docker daemon.
  // Only either `socketPath` or `proxy` can be specified.
  // If both are specified, `socketPath` is used.
  socketPath: null, // default

  // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：
  // `keepAlive` 默认没有启用
  httpAgent: new http.Agent({ keepAlive: true }),
  httpsAgent: new https.Agent({ keepAlive: true }),

  // 'proxy' 定义代理服务器的主机名称和端口
  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据
  // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。
  proxy: {
    host: '127.0.0.1',
    port: 9000,
    auth: {
      username: 'mikeymike',
      password: 'rapunz3l'
    }
  },

  // `cancelToken` 指定用于取消请求的 cancel token
  // （查看后面的 Cancellation 这节了解更多）
  cancelToken: new CancelToken(function (cancel) {
  })
}
```

### 响应结构

```js
{
  // `data` 由服务器提供的响应
  data: {},

  // `status` 来自服务器响应的 HTTP 状态码
  status: 200,

  // `statusText` 来自服务器响应的 HTTP 状态信息
  statusText: 'OK',

  // `headers` 服务器响应的头
  headers: {},

   // `config` 是为请求提供的配置信息
  config: {},
 // 'request'
  // `request` is the request that generated this response
  // It is the last ClientRequest instance in node.js (in redirects)
  // and an XMLHttpRequest instance the browser
  request: {}
}
```

### 配置默认值 / 配置优先顺序

```js
全局axios默认值：
axios.defaults.baseURL = 'https://api.example.com';
axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;
axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';
自定义实例默认值：
// Set config defaults when creating the instance
const instance = axios.create({
  baseURL: 'https://api.example.com'
});

// Alter defaults after instance has been created
instance.defaults.headers.common['Authorization'] = AUTH_TOKEN;
```

```js
配置的优先顺序：
配置会以一个优先顺序进行合并。这个顺序是：在 lib/defaults.js 找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。这里是一个例子：

// 使用由库提供的配置的默认值来创建实例
// 此时超时配置的默认值是 `0`
var instance = axios.create();

// 覆写库的超时默认值
// 现在，在超时前，所有请求都会等待 2.5 秒
instance.defaults.timeout = 2500;

// 为已知需要花费很长时间的请求覆写超时设置
instance.get('/longRequest', {
  timeout: 5000
});

总体来说：config参数 > 实例defaults > lib/defaults.js中库的默认值
```

### 拦截器

在请求或响应被 then 或 catch 处理前拦截它们。

```js
// 添加请求拦截器
axios.interceptors.request.use(function (config) {
    // 在发送请求之前做些什么
    return config;
  }, function (error) {
    // 对请求错误做些什么
    return Promise.reject(error);
  });

// 添加响应拦截器
axios.interceptors.response.use(function (response) {
    // 对响应数据做点什么
    return response;
  }, function (error) {
    // 对响应错误做点什么
    return Promise.reject(error);
  });
```

如果你想在稍后移除拦截器，可以这样：

```js
const myInterceptor = axios.interceptors.request.use(function () {/*...*/});
axios.interceptors.request.eject(myInterceptor);
```

可以为自定义 axios 实例添加拦截器

```js
const instance = axios.create();
instance.interceptors.request.use(function () {/*...*/});
```

### 取消

使用 *cancel token* 取消请求，可以使用 `CancelToken.source` 工厂方法创建 cancel token，像这样：

```js
const CancelToken = axios.CancelToken;
const source = CancelToken.source();

axios.get('/user/12345', {
  cancelToken: source.token
}).catch(function(thrown) {
  if (axios.isCancel(thrown)) {
    console.log('Request canceled', thrown.message);
  } else {
     // 处理错误
  }
});

axios.post('/user/12345', {
  name: 'new name'
}, {
  cancelToken: source.token
})

// 取消请求（message 参数是可选的）
source.cancel('Operation canceled by the user.');

```

还可以通过传递一个 executor 函数到 `CancelToken` 的构造函数来创建 cancel token：

```js
const CancelToken = axios.CancelToken;
let cancel;

axios.get('/user/12345', {
  cancelToken: new CancelToken(function executor(c) {
    // executor 函数接收一个 cancel 函数作为参数
    cancel = c;
  })
});

// cancel the request
cancel();
```

注意: 可以使用同一个 cancel token 取消多个请求

### vue中封装axios（创建实例，添加拦截器）

```js
在vue中封装axios的思路：
    我们需要一次性集中配置axios，让配置适应我们项目的大部分场景。我们可以新建一个js文件，使用自定义配置新建一个 axios 实例，然后对实例进行基本配置，在请求前(请求体处理)，请求后(返回的结果处理)等这些阶段添加一些我们需要的处理，然后将其导出使用。
    
 封装操作：
* request.js
import axios from 'axios'
export function request(config){
    const instance = axios.create({
        baseURL: '...',
        timeout: 5000
    })
    // 添加拦截器，用于处理发送请求前后、出现错误时进行的操作
    instance.interceptors.request.use(config => {
        return config
    }, err => Promise.error(err))
    instance.interceptors.response.use(res => {
        return res.data
    },err =>  Promise.error(err))
    
    return instance(config)
    // 这是个promise对象
}

* home.js中使用：
import {request} from './request'
export function getHomeMultidata(){
    return request({
        url: '/home/multidata'
    })
}
export function getHomeGoods(type, page){
    return request({
        url: '/home/data',
        params: {
            type,
            page
        }
    })
}

* Home.vue中使用：
import {getHomeMultidata, getHomeGoods} from '../../network/home'

methods:{
    getHomeMultidata(){
		getHomeMultidata().then(res => {
            this.banners = res.data.banner.list
            this.recommends = res.data.recommend.list
        })
    },
    getHomeGoods(type){
        const page = this.goods[type].page + 1
        getHomeGoods(type, page).then(res => {
            this.goods[type].list.push(...res.data.list)
            this.godds[type].page += 1
        })
    }
}
```

## 5.3 模块化

```
CommonJS & ES6 module
一、CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用
CommonJS加载的变量无法通过加载的方法修改了
ES6可以

二、CommonJS 模块是运行时加载，ES6 模块是编译时输出接口
CommonJS是加载整个模块，然后从模块对象上取方法、对象、变量等，称为运行时加载
ES6模块化是一种接口定义，在代码解析阶段就会生成，称为编译时加载

三、CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段
```

## 5.4 class与构造函数的区别

```js
class Mac {
    val = '';
    constructor(symbol) {
        this.symbol = symbol
    }
    set(val) {
        let valArr = val.split(this.symbol)
        let reg = /[0-9a-fA-F]{2}/
        if (valArr.length !== 6) return false
        for (let v of valArr) {
            if (!reg.test(v)) return false
        }
        this.val = val
    }
    valueOf () {
        return this.val
    }
}

// 等同于：
function Mac(symbol) {
    this.symbol = symbol
}
Mac.prototype.set = function (val) {
    let valArr = val.split(this.symbol)
    let reg = /[0-9a-fA-F]{2}/
    if (valArr.length !== 6) return false
    for (let v of valArr) {
        if (!reg.test(v)) return false
    }
    this.val = val
}
Mac.prototype.valueOf = function () {
    return this.val
}

let mac = new Mac('-')
mac.set('11-22-33-44-55-66')
console.log(mac.valueOf())
console.log(mac == '11-22-33-44-55-66')
console.log('Object.getOwnPropertyNames', Object.getOwnPropertyNames(mac))
console.log('Object.keys', Object.keys(mac))
for(let prop in mac) {
    console.log('for in', prop)
}
Reflect.ownKeys(mac).forEach(key => console.log('Reflect.ownKeys', key))
```

+ ES6中的类是构造函数的语法糖

+ 在class中定义方法，其实就是在原型链上添加方法

+ class的所有内部定义的方法都不可被枚举（与es5不同）

+ constructor

  + constructor方法是类的默认方法，在使用 new 命令生成实例时会自动调用此方法，如果constructor方法没有被定义，则默认添加一个空的constructor方法

  + constructor方法默认返回实例对象（也就是this），也可以自己设置返回的对象

  + 其实实例属性可以不写在constructor内，也可以写在类的顶层,此时_count属性与取值函数value以及increment在同一级，不需要在前面加this。与在constructor中定义意义一样，但看起来比较简洁

    + ```js
      class IncreasingCounter {
        _count = 0;
        get value() {
          console.log('Getting the current value!');
          return this._count;
        }
        increment() {
          this._count++;
        }
      }
      ```

+ class必须用new操作符调用（与ES5不同，构造函数可直接调用）

+ 实例的属性除非显式定义在其本身（即定义在`this`对象上），否则都是定义在原型上（即定义在`class`上）

+ class的所有实例共享一个原型对象

+ 在class中可以使用`get`和`set`关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为

  + ```js
    class MyClass {
      constructor() {
        // ...
      }
      get prop() {
        return 'getter';
      }
      set prop(value) {
        console.log('setter: '+value);
      }
    }
     
    let inst = new MyClass();
     
    inst.prop = 123;
    // setter: 123
     
    inst.prop
    // 'getter'
    ```

+ 存值函数和取值函数是设置在属性的 Descriptor 对象上的

+ class不存在变量提升（与ES5不同）

+ 静态方法（静态属性与静态方法定义方法一致）

  + 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”
  + **如果在静态方法中使用到了this，这个this指向类本身，而不是实例（且静态方法与非静态方法可以重名）**

+ 私有属性和私有方法

  + 有时有一些属性和方法我们希望只允许在类的内部使用，此时他们就是私有属性和私有方法

  + 可以在属性或方法前加#，此时该属性或方法只能在类中被取到

  + 私有属性和私有方法也可以被设置setter和getter，也可以在之前加static被设置为静态的私有属性和私有方法

  + ```js
    //私有属性
    class IncreasingCounter {
      #count = 0;
      get value() {
        console.log('Getting the current value!');
        return this.#count;
      }
      increment() {
        this.#count++;
      }
    }
     
    const counter = new IncreasingCounter();
    counter.#count // 报错
    counter.#count = 42 // 报错
     
    //私有方法
    class Foo {
      #a;
      #b;
      constructor(a, b) {
        this.#a = a;
        this.#b = b;
      }
      #sum() {
        return this.#a + this.#b;
      }
      printSum() {
        console.log(this.#sum());
      }
    }
    ```

# 7. Vue源码解析

```
文件夹Vue
```

# 8. TypeScript

## 8.1 TypeScript介绍及初使用

```js
1. TypeScript是JavaScript的超集，遵循最新的ES6、ES5规范，扩展了JavaScript的语法
2. Angular2.x基于TS语法，Vue React也可以集成TS
3. Node.js框架Nestjs,midway中也用的TS语法
```

### 8.1.1 自动编译 .ts 文件

```
1. 项目中 tsc --init -> 自动生成一个tsconfig.json文件
2. 进入tsconfig.json中，找到 "outDir": "./" ，将其修改为 "outDir": "./js"
3. 点击VSCode上的 终端 -> 运行任务，选择typescript -> tsc: 监视
4. 保存ts文件后，自动生成文件夹及对应的ts文件， js/xxx.js
```

### 8.1.2 TypeScript中的数据类型

```
布尔类型（boolean）
数字类型（number）
字符串类型（string）
数组类型（array）
元组类型（tuple）
枚举类型（enum）
任意类型（any）
null、undefined
void类型
never类型
```

```typescript
布尔型： true false
var flag:boolean = true
flag = false
```

```typescript
数字类型：
var a:number = 123
console.log(a) // 123
a = 'string' // ts自动报错
a = 12.3 // 可以
```

```typescript
字符串类型：
var str:string = 'this is ts'
str = 'hello ts'
```

```typescript
数组类型：
JavaScript中：
let arr = [1,'324',[1,2],function fun(){},obj:{a:1},false]

TypeScript中：
1. 第一种定义数组的方式：
let arr:number[] = [1,2,3] // 只能放number类型元素
let arr2:string[] = ['ts','js','ss']

2. 第二种定义数组的方式：（泛型）
let arr:Array<number> = [1,2,3]
let arr2:Array<string> = ['ts','js','ss']

3. 第三种定义数组的方式：any
let arr:any[] = ['fadf',12312,true]
```

```typescript
元组类型(tuple)： 
* 属于数组的一种
* 可以指定元素类型，必须是一一对应
let arr:[string,number,boolean] = ['ts',1.23,false]
```

```typescript
枚举类型(enum)：
* 用来定义标识符
enum pay_status{
  unpaid = 0,
  pay = 1,
  paid = 2
}
let pay:pay_status = pay_status.pay
console.log(pay) // 1
console.log(pay_status.pay) // 1
--------------------------------------------------------
* 不赋值时，默认是索引值
enum Color { red, blue = 5, orange}
let r:Color = Color.red
let b:Color = Color.blue
let o:Color = Color.orange
console.log(r) // 0
console.log(b) // 5
console.log(o) // 6
--------------------------------------------------------
* 数字枚举原理： 反向映射
var Role;
(function (Role) {
    Role[Role["Reporter"] = 1] = "Reporter";
    Role[Role["Developer"] = 2] = "Developer";
    Role[Role["Maintainer"] = 3] = "Maintainer";
    Role[Role["Owner"] = 4] = "Owner";
    Role[Role["Guest"] = 5] = "Guest";
})(Role || (Role = {}));
--------------------------------------------------------
* 枚举成员是只读的
```

```typescript
任意类型(any):
let num:any = 123
num = 'str'
num = false
------------------------------------------------------
let oBox:any = document.getElementById('box')
oBox.style.color = 'red'
```

```typescript
null和undefined：
* 其他数据类型的子类型
let num:number
console.log(num) // undefined 报错
let n:undefined
console.log(n) // undefined 正确
-------------------------------------------
let n2:number | undefined | null
console.log(n2) // undefined 正确
```

```typescript
void类型：
* 表示没有任何类型，一般用于定义方法的时候方法没有返回值
// 没返回值（return）就用void
function fun ():void {
  console.log('fun')
}
// 定义了返回值的类型就必须return对应的类型，否则报错
function func():number {
  return 123
}
```

```
never类型：
* 是其他类型（包括undefined、null）的子类型，代表从不会出现的值
* 意味着声明never的变量只能被never类型所赋值
```

### 8.1.3 TypeScript中的函数

#### 函数定义

```typescript
1. 函数声明法：
function fun ():string {
  return '我是函数声明法string!'
}
fun()
function fun ():void {
  console.log('fun')
}
2. 匿名函数法：
let fun = function ():number {
    return 123
}
fun()
```

#### 方法传参

```typescript
1. 函数声明法：
function getInfo (name:string, age:number):string {
  return `${name}---${age}`
}
console.log(getInfo('txf', 23)) // txf---23
2. 匿名函数法：
let getInfo = function (name:string, age:number):string {
  return `${name}---${age}`
}
console.log(getInfo('txf2', 230)) // txf2---230
```

#### 可选参数

```typescript
ES5中，方法的实参和形参可以不一样，但是在ts中，必须数量一致，如果不一致，则需要配置【可选参数】
* 可选参数需要在参数后加 【?】
function getInfo3 (name:string, age?:number):string {
  if (age) {
    return `${name}---${age}`
  } else {
    return `${name}---没有年龄，我保密！`
  }
}
console.log(getInfo3('txf')) // txf---没有年龄，我保密！
console.log(getInfo3('txf', 22)) // txf---22

// 注意： 可选参数必须要配置到参数列表的最后
```

#### 默认参数

```typescript
ES5中无法设置默认参数，ES6和ts中都可以设置默认参数（也是可选参数的一种，不传参，函数中就使用默认的值）
function getInfo4 (name:string, age:number=18):string {
  if (age) {
    return `${name}---${age}`
  } else {
    return `${name}---默认年龄：${age}`
  }
}
console.log(getInfo4('ttt')) // ttt---18
console.log(getInfo4('xxx', 100)) // xxx---100
```

#### 剩余参数

```typescript
function sum (a:number, b:number, c:number, d:number):number {
  return a + b + c + d
}
console.log(sum(1,2,3,4)) // 10

// ES6 三点运算符 接收形参传过来的值
function sum2 (...result:number[]):number {
  let sum = 0
  for (let i = 0; i < result.length; i++) {
    sum += result[i]
  }
  return sum
}
console.log(sum2(1,2,3,4,5,6)) // 21
// 拓展写法
function sum3 (a:number, b:number, ...result:number[]):number {
  let sum = a + b
  for (let i = 0; i < result.length; i++) {
    sum += result[i]
  }
  return sum
}
console.log(sum3(1,2,3,4,5,6)) // 21
```

#### 函数重载

```typescript
java中方法的重载，指两个或两个以上同名函数，但它们参数不同，这时会出现函数重载
typescript中的重载，通过为同一个函数提供多个函数类型定义来实现多种功能的目的
ts为了兼容es5以及es6重载的写法，和java有区别
* es5中，同名函数，下面的替换上面的
* 重载就是为了在定义函数时定义的形参，可能有需要限制参数数据类型的需求，就需要用到重载
* 重载使得同样的方法，传入不同的参数，实现不同的功能
// 方法重载（参数不同）
function foo (name:string):string 
function foo (age:number):number 
function foo (m:any):any {
    if (typeof m === 'string') {
        return '我的名字是：' + m
    } else {
        return '我的年龄是：' + m
    }
}
console.log(foo('txf')) // 我的名字是：txf
console.log(foo(123)) // 我的年龄是：123
console.log(foo([1,2,3])) // 错误写法
// 错误提示：
没有与此调用匹配的重载。
  第 1 个重载(共 2 个)，“(name: string): string”，出现以下错误。
    类型“number[]”的参数不能赋给类型“string”的参数。
  第 2 个重载(共 2 个)，“(age: number): number”，出现以下错误。
    类型“number[]”的参数不能赋给类型“number”的参数。ts(2769)
----------------------------------------------------------------------------------------------------------
// 方法重载（参数相同）
function bar (name:string):string
function bar (name:string, age:number):string
function bar (name:any, age?:any):any {
  if (age) {
    return '我的名字是：' + name + '我的年龄是：' + age
  } else {
    return `我叫${name}`
  }
}
console.log(bar('txffxt666')) // 我叫txffxt666
// console.log(bar(123)) // 报错
```

### 8.1.4 TypeScript中的类

#### 类的定义

```typescript
class Person {
  name: string // 属性 前面省略了public关键字
  constructor (name:string) { // 构造函数 实例化类时触发的方法 参数就是实例化时传入的参数
    this.name = name
  }
  run ():void {
    console.log(this.name + '在奔跑')
  }
  getName ():string {
    return this.name
  }
  setName (name:string):void {
    this.name = name
  }
}
let p = new Person('张全蛋')
p.run() // 张全蛋在奔跑
console.log(p.getName()) // 张全蛋
p.setName('黑山老妖')
console.log(p.getName()) // 黑山老妖 
```

#### 继承

```typescript
* 通过 extends super 两个关键字实现继承
class People {
  name:string
  constructor (name:string) {
    this.name = name
  }
  run ():string {
    return `${this.name}在奔跑`
  }
}
let peo = new People('刘子')
console.log(peo.run()) // 刘子在奔跑

class Stu extends People {
  age:number
  constructor (name:string, age:number) {
    super(name) // 初始化父类的构造函数
    this.age = age
  }
  run ():string {
    return `子类里的${this.age}岁的${this.name}在奔跑`
  }
  work():string {
    return `${this.age}岁的${this.name}在工作`
  }
}
let stu = new Stu('老灯', 88)
// 子类中的方法屏蔽了父类中的
console.log(stu.run()) // 子类里的88岁的老灯在奔跑
console.log(stu.work()) // 88岁的老灯在工作
```

#### 类里面的修饰符

```typescript
* 类里定义属性的时候，ts提供了三种修饰符
* 1. public: 公有           在类里面、子类、类外面都可以访问
* 2. protected：保护类型     在类里面、子类里面可以访问，在类外部无法访问
* 3. private：私有          只能在类里面访问
* 属性如果不加修饰符，默认是公有public

class Vehicle {
  protected name:string // 公有属性
  constructor (name:string) {
    this.name = name
  }
  run ():string {
    return `${this.name}在跑`
  }
  pro ():string {
    return `${this.name}在生产`
  }
}
class Car extends Vehicle {
  private price:number
  constructor (name:string, price:number=1200) {
    super(name)
    this.price = price
  }
  sayPrice ():string {
    return `${this.name}的价格是：${this.price}`
  }
}
let v = new Vehicle('轮船')
// console.log(v.name) // 提示：属性“name”受保护，只能在类“Vehicle”及其子类中访问。
let c = new Car('宝马')
console.log(c.sayPrice()) // 宝马的价格是：1200
// 类外部访问：
// console.log(c.price) // 提示：属性“price”为私有属性，只能在类“Car”中访问
```

#### 静态属性 静态方法

```typescript
ES5中：
* 例：jq中的$，既有静态$.get等方法，也有$('#box').css等实例化方法
function A () {
  this.run1 = function () {

  }
}
A.name = '111' /* 静态属性 */
A.run2 = function () { /* 静态方法 */

}
let aaa = new A()
aaa.run1()
A.run2() /* 静态方法的调用 */

ts中：
class Bag {
  name:string
  demention:number
  /* 静态属性 */
  static staProp:string = '我是静态属性,属于类,不属于实例'
  constructor (name:string, demention:number=20) {
    this.name = name
    this.demention = demention
  }
  size ():string {
    return `${this.name}有${this.demention}寸`
  }
  static load () { /* 静态方法 */
    return `我是静态方法，能装东西，还能调用静态属性：【${this.staProp}】`
    /* 静态方法中，无法直接调用类中的属性，除了静态属性，还除了name属性，是类名Bag */
  }
}
let bag = new Bag('双肩包')
console.log(bag.size()) // 双肩包有20寸
console.log(Bag.load()) // 我是静态方法，能装东西，还能调用静态属性：【我是静态属性,属于类,不属于实例】
console.log(Bag.staProp) // 我是静态属性,属于类,不属于实例
Bag.staProp = '已修改静态属性'
console.log(Bag.staProp) // 已修改静态属性
// console.log(bag.staProp) // 无法调用
```

#### 抽象类 继承 多态

```typescript
多态：

* 父类定义一个方法不去实现，让继承它的子类去实现，每一个子类有不同的表现
* 多态属于继承
class Animal {
  name:string
  constructor (name:string) {
    this.name = name
  }
  eat () { // 具体怎么做,由子类实现,每个子类各不相同
    console.log('吃什么捏?')
  }
}
class Dog extends Animal {
  constructor (name:string) {
    super(name)
  }
  eat () { 
    return this.name + '吃粑粑'
  }
}
class Cat extends Animal {
  constructor (name:string) {
    super(name)
  }
  eat () {
    return this.name + '吃鱼'
  }
}
let animal = new Animal('小动物')
animal.eat() // 吃什么捏?
```

```typescript
抽象方法 抽象类：

* ts中的抽象类，是提供其他类继承的基类，不能直接被实例化
* 用 abstract 关键字定义抽象类和抽象方法，抽象类中的抽象方法不包含具体实现并且必须在派生类中实现
* abstract 抽象方法只能放在抽象类里
* 抽象类和抽象方法用来定义标准
* 例： 标准： Animal这个类要求它的子类必须包含 eat 方法
// 定义标准
abstract class Animal {
  public name:string
  constructor (name:string) {
    this.name = name
  }
  abstract eat ():string 
}
class Dog extends Animal {
  constructor (name:string) {
    super(name)
  }
  // 抽象类的子类,必须实现抽象类里面的抽象方法
  eat ():string {
    return this.name + '吃粑粑'
  }
}
// class Cat extends Animal {
/* 报错: 非抽象类“Cat”没有实现继承自“Animal”类的抽象成员“eat” */
//   constructor (name:any) {
//     super(name)
//   }
//   run () {

//   }
// }
// let a = new Animal() // 报错 提示: 无法创建抽象类的实例。
let d = new Dog('修勾')
console.log(d.eat()) // 修勾吃粑粑
```

### 8.1.5 接口

#### 接口的作用

```
在面向对象的编程中，接口是一种规范的定义，它定义了行为和动作的规范，在程序设计里面，接口起到一种限制和规范的作用。接口定义了某一批类所需要遵守的规范，接口不关心这些类的内部状态数据，也不关心这些类里方法的实现细节，它只规定这批类里必须提供某些方法，提供这些方法的类就可以满足实际需要。 typescrip中的接口类似于java，同时还增加了更灵活的接口类型，包括属性、函数、可索引和类等。
定义标准

它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）
TypeScript 中的接口是一个非常灵活的概念，除了可用于[对类的一部分行为进行抽象]以外，也常用于对「对象的形状（Shape）」进行描述。
```

#### 属性接口

```typescript
* 对json的约束
// ts中自定义方法传入参数对 json 进行约束
// 对一个方法进行参数约束
function printLabel (labelInfo:{label:string}):void {
  console.log('printLabel')
}
let labelObj = {
  label: 'obj中的laebl'
}
printLabel(labelObj)

* 通过 interface 关键字对批量方法传入参数进行约束
// 约束了传入对象的属性及类型    属性接口
interface FullName {
  // 要求传入的参数对象中,必须同时包含有以下两个属性
  firstName:string
  lastName:string
  // 可选参数，可传可不传
  midlleName?:string
}
function printName (name:FullName) {
  // 必须传入对象 firstName lastName
  console.log(name.firstName + '-' + name.lastName)
}
function printInfo (info:FullName) {
  console.log(info.firstName + '-' + info.lastName)
}
let person = {
  firstName: '童',
  lastName: '雪枫',
  age: 22
}
printName(person) // 童-雪枫
printInfo(person) // 童-雪枫
```

```typescript
举个例子！
/*
  $.ajax({
    type: 'GET',
    url: 'test.json',
    data: {username:$('#username').val(), content:$('#content').val()},
    dataType: 'json'
  })
*/

interface Config {
  type:string
  url:string
  data?:string
  dataType:string
}
function ajax (config:Config) {
  let xhr = new XMLHttpRequest()
  xhr.open(config.type, config.url, true)
  xhr.send(config.data)
  xhr.onreadystatechange = function () {
    if (xhr.readyState === 4 && xhr.status === 200) {
      console.log('成功')
      if (config.dataType === 'json') {
        console.log(JSON.parse(xhr.responseText))
      } else {
        console.log(xhr.responseText)
      }
    }
  }
}
ajax({
  type: 'get',
  url: 'http://a.itying.com/api/productlist',
  dataType: 'json'
})
```

#### 函数类型接口

```typescript
* 对方法传入的参数以及返回值进行约束
// 约束函数传入参数类型以及返回值类型(非对象)    批量约束
interface encrypt {
  (key:string, value:string):string
}
var md5:encrypt = function (key:string, value:string):string {
  return key + '-----' + value
}
console.log(md5('name','txf')) // name-----txf
```

#### 可索引接口

```typescript
// 对数组/对象的约束(不常用)
interface Arr {
  [index:number]: string
}
let array:Arr = ['123','123']
console.log(array[0])
```

#### 类类型接口

```typescript
* 对类的约束  和 抽象类 有点相似
interface Animal2 {
  name:string
  eat2 (str:string):void
}
class Lmx implements Animal2 {
  name:string
  constructor (name:string) {
    this.name = name
  }
  eat2 () {
    console.log(this.name + '吃粑粑')
  }
}
class Txf implements Animal2 {
  name:string
  constructor (name:string) {
    this.name = name
  }
  eat2 (food:string) {
    console.log(this.name + '吃' + food)
  }
}
let lmx = new Lmx('lmx')
lmx.eat2() // lmx吃粑粑
let txf = new Txf('txf')
txf.eat2('满汉全席') // txf吃满汉全席
```

#### 接口的扩展

```typescript
* 接口可以继承接口
interface Animal3 {
  eat ():void
}
interface Per extends Animal3 {
  work ():void
}
class Programmer {
  name:string
  constructor (name:string) {
    this.name = name
  }
  coding (code:string) {
    console.log(this.name + code)
  }
}
class Web extends Programmer implements Per {
  constructor (name:string) {
    super(name)
  }
  work () {
    console.log(this.name + '在工作')
  }
  eat () {
    console.log(this.name + '吃大餐')
  }
}
let weber = new Web('txf')
weber.work() // txf在工作
weber.eat() // txf吃大餐
weber.coding('写ts代码') // txf写ts代码
```

#### 避开属性检查的方法

##### 1. 鸭辨式

```typescript
interface LabeledValue {
  label: string;
}
function printLabel(labeledObj: LabeledValue) {
  console.log(labeledObj.label);
}
let myObj = { size: 10, label: "Size 10 Object" };
printLabel(myObj); // OK

// -------------------------------------------------------
interface LabeledValue {
  label: string;
}
function printLabel(labeledObj: LabeledValue) {
  console.log(labeledObj.label);
}
printLabel({ size: 10, label: "Size 10 Object" }); // Error

```

##### 2. 类型断言

```typescript
interface Props { 
  name: string; 
  age: number; 
  money?: number;
}

let p: Props = {
  name: "兔神",
  age: 25,
  money: -100000,
  girl: false
} as Props; // OK
```

##### 3. 索引签名

```typescript
interface Props { 
  name: string; 
  age: number; 
  money?: number;
  [key: string]: any;
}

let p: Props = {
  name: "兔神",
  age: 25,
  money: -100000,
  girl: false
}; // OK
```

#### 接口与类型别名的区别

##### Objects / Functions

```typescript
// interface
interface Point {
  x: number;
  y: number;
}

interface SetPoint {
  (x: number, y: number): void;
}

// type alias 
type Point = {
  x: number;
  y: number;
};

type SetPoint = (x: number, y: number) => void;
```

##### Other Types

```typescript
// 与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组。

// primitive
type Name = string;

// object
type PartialPointX = { x: number; };
type PartialPointY = { y: number; };

// union
type PartialPoint = PartialPointX | PartialPointY;

// tuple
type Data = [number, string];

// dom
let div = document.createElement('div');
type B = typeof div;
```

##### 接口可以定义多次,类型别名不可以

```typescript
// 与类型别名不同，接口可以定义多次，会被自动合并为单个接口。
interface Point { x: number; }
interface Point { y: number; }
const point: Point = { x: 1, y: 2 };
```

#### 扩展

##### 接口扩展接口(extends)

```typescript
interface PointX {
    x: number
}

interface Point extends PointX {
    y: number
}
```

##### 类型别名扩展类型别名(&)

```typescript
type PointX = {
    x: number
}

type Point = PointX & {
    y: number
}
```

##### 接口扩展类型别名(extends)

```typescript
type PointX = {
    x: number
}
interface Point extends PointX {
    y: number
}
```

##### 类型别名扩展接口(&)

```typescript
interface PointX {
    x: number
}
type Point = PointX & {
    y: number
}
```

### 8.1.6 泛型

#### 泛型的定义

```typescript
软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。
在像C#和Java这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。
* 通俗理解：泛型就是解决 类 接口 方法的复用性、以及对不特定数据类型的支持(类型校验)
// 只能返回string类型的数据
function getData (value:string):string {
  return value
}
```

#### 泛型函数

```typescript
// 泛型可以支持不特定的数据类型   
// 要求: 传入参数和返回参数一致
// any 可以,但是放弃了类型检查

// T表示泛型,具体什么类型是调用这个方法时决定 
function getData2<T> (value:T):T {
  return value
}
getData2<number>(123)
getData2<string>('123')

function getData3<T> (value:T):any {
  return 'value'
}
getData2<number>(123) // 参数必须是number
getData2<string>('123')
```

#### 泛型类

```typescript
// 比如有个最小堆算法,需要同时支持返回数字和字符串两种类型.  可以通过类的泛型来实现
class MinClass {
  public list:number[] = []
  add (num:number) {
    this.list.push(num)
  }
  min ():number {
    var minNum = this.list[0]
    for (let i = 0; i < this.list.length; i++) {
      if (minNum > this.list[i]) {
        minNum = this.list[i]
      }
    }
    return minNum
  }
}
let mc = new MinClass()
mc.add(1)
mc.add(2)
mc.add(-1000)
console.log(mc.min()) // -1000

// 类的泛型
class MinClass2<T> {
  public list:T[] = []
  add (value:T) {
    this.list.push(value)
  }
  min ():T {
    var minNum = this.list[0]
    for (let i = 0; i < this.list.length; i++) {
      if (minNum > this.list[i]) {
        minNum = this.list[i]
      }
    }
    return minNum
  }
}
let mc2 = new MinClass2<number>() // 实例化类 指定类的T代表的类型是number
mc2.add(3)
mc2.add(8)
mc2.add(99)
console.log(mc2.min()) // 3

let mc3 = new MinClass2<string>() // 实例化类 指定类的T代表的类型是number
mc3.add('bcd')
mc3.add('abc')
mc3.add('cde')
console.log(mc3.min()) // abc
```

#### 泛型接口

```typescript
// 函数类型接口
interface ConfigFn {
  (value1:string, value2:string):string
}
var getVal:ConfigFn = function (value1:string, value2:string):string {
  return value1 + '-' + value2
}
console.log(getVal('name','txf')) // name-txf

// 改造为泛型接口
interface ConfigFn2 {
  <T>(value:T):T
}
var getVal2:ConfigFn2 = function<T> (value:T):T {
  return value
}
console.log(getVal2<string>('name')) // name

// 或者:
interface ConfigFn3<T> {
  (value:T):T
}
function getVal3<T> (value:T):T {
  return value
}
var myGetVal:ConfigFn3<string> = getVal3
console.log(myGetVal('222')) // 222
console.log(myGetVal('abc')) // abc
```

#### 把类作为参数类型的泛型类

```typescript
/* 
  定义一个User类,作用是映射数据库字段
  然后定义一个MysqlDb类,用于操作数据库
  然后把User类作为参数传入到MysqlDb中
*/
// 把类作为参数来约束数据传入的类型
class User {
  username:string | undefined
  password:string | undefined
}
class MysqlDb {
  add (user:User):boolean {
    console.log(user)
    return true
  }
}
let user = new User()
user.username = 'txf'
user.password = '123456'
let db = new MysqlDb()
db.add(user)
/*
  Object { username: "txf", password: "123456" }
*/

class ArticleCate {
  title:string | undefined
  desc:string | undefined
  status: number | undefined
}
class MysqlDb2 {
  add (category:ArticleCate):boolean {
    console.log(category)
    return true
  }
}
let art = new ArticleCate()
art.title = '海底两万里'
art.desc = '名著'
art.status = 1
let db2 = new MysqlDb2()
db2.add(art)
/* 
  Object { title: "海底两万里", desc: "名著", status: 1 }
*/

// 泛型校验传入的类参数
class MysqlDb3<T> {
  add (val:T):boolean {
    console.log(val)
    return true
  }
}
// 给product表加数据,然后跟数据库映射
class Product {
  name: string | undefined
  price: number | undefined
  storage: number | undefined
}
let product = new Product()
product.name = '趣多多'
product.price = 10
product.storage = 1000
let db3 = new MysqlDb3<Product>()
db3.add(product)
/*
  Object { name: "趣多多", price: 10, storage: 1000 }
*/
// db3.add(123) // 报错

// 定义一个house类 和数据库表映射
class House {
  location: string | undefined
  price: number | undefined
  constructor (params: {
    location: string | undefined,
    price: number | undefined
  }) {
    this.location = params.location
    this.price = params.price
  }
}
let house = new House({
  location: '深圳湾一号',
  price: 20
})
let db4 = new MysqlDb3<House>()
db4.add(house)
/* 
  Object { location: "深圳湾一号", price: 20 }
*/
```

#### 泛型工具类型

##### typeof

```typescript
// typeof 的主要用途是在类型上下文中获取变量或者属性的类型

interface Person {
  name: string;
  age: number;
}
const sem: Person = { name: "semlinker", age: 30 };
type Sem = typeof sem; // type Sem = Person

// 嵌套对象：

const Message = {
    name: "jimmy",
    age: 18,
    address: {
      province: '四川',
      city: '成都'   
    }
}
type message = typeof Message;
/*
 type message = {
    name: string;
    age: number;
    address: {
        province: string;
        city: string;
    };
}
*/

// 函数对象类型：

function toArray(x: number): Array<number> {
  return [x];
}
type Func = typeof toArray; // -> (x: number) => number[]
```

##### keyof

```typescript
// keyof 操作符是在 TypeScript 2.1 版本引入的，该操作符可以用于获取某种类型的所有键，其返回类型是联合类型。

interface Person {
  name: string;
  age: number;
}

type K1 = keyof Person; // "name" | "age"
type K2 = keyof Person[]; // "length" | "toString" | "pop" | "push" | "concat" | "join" 
type K3 = keyof { [x: string]: Person };  // string | number

// 数字索引 & 字符串索引

interface StringArray {
  // 字符串索引 -> keyof StringArray => string | number
  [index: string]: string; 
}

interface StringArray1 {
  // 数字索引 -> keyof StringArray1 => number
  [index: number]: string;
}
```

```typescript
// keyof应用

type Todo = {
  id: number;
  text: string;
  done: boolean;
}

const todo: Todo = {
  id: 1,
  text: "Learn TypeScript keyof",
  done: false
}

function prop<T extends object, K extends keyof T>(obj: T, key: K) {
  return obj[key];
}

const id = prop(todo, "id"); // const id: number
const text = prop(todo, "text"); // const text: string
const done = prop(todo, "done"); // const done: boolean
```

#####  extends

```typescript
// 有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。
interface Lengthwise {
  length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
  console.log(arg.length);
  return arg;
}

// 我们需要传入符合约束类型的值，必须包含length属性：
loggingIdentity(3);  // Error, number doesn't have a .length property

loggingIdentity({length: 10, value: 3});
```

##### in

```typescript
// in 用来遍历枚举类型

type Keys = "a" | "b" | "c"

type Obj =  {
  [p in Keys]: any
} // -> { a: any, b: any, c: any }
```

##### infer

```typescript
// 在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用。

type ReturnType<T> = T extends (
  ...args: any[]
) => infer R ? R : any;

// 用它取到函数返回值的类型方便之后使用。
```

##### 索引类型

```typescript
// T[K]表示对象T的属性K所表示的类型，在上述例子中，T[K][] 表示变量T取属性K的值的数组
function getValues<T, K extends keyof T>(person: T, keys: K[]): T[K][] {
  return keys.map(key => person[key]);
}

interface Person {
    name: string;
    age: number;
}

const person: Person = {
    name: 'musion',
    age: 35
}

getValues(person, ['name']) // ['musion']
getValues(person, ['gender']) // 报错：

```



## 8.2 综合使用类型、接口、类、泛型

### TypeScript封装统一操作Mysql Mongodb Mssql的底层库

```typescript
/*
功能：定义一个操作数据库的库  支持 Mysql Mssql  MongoDb
要求1：Mysql MsSql  MongoDb功能一样  都有 add  update  delete  get方法    
注意：约束统一的规范、以及代码重用
解决方案：需要约束规范所以要定义接口 ，需要代码重用所以用到泛型
    1、接口：在面向对象的编程中，接口是一种规范的定义，它定义了行为和动作的规范
    2、泛型 通俗理解：泛型就是解决 类 接口 方法的复用性、
*/
interface DBI<T> {
  add (info:T): boolean 
  update (info:T, id:number): boolean
  delete (id:number): boolean
  get (id:number): any[]
}
// 定义操作数据库的类    要实现泛型接口,类必须是泛型类
class Mysqldb<T> implements DBI<T> {
  add(info: T): boolean {
    console.log(info)
    return true
  }
  update(info: T, id: number): boolean {
    throw new Error("Method not implemented.");
  }
  delete(id: number): boolean {
    throw new Error("Method not implemented.");
  }
  get(id: number): any[] {
    throw new Error("Method not implemented.");
  }
}
class Mssqldb<T> implements DBI<T> {
  add(info: T): boolean {
    throw new Error("Method not implemented.");
  }
  update(info: T, id: number): boolean {
    throw new Error("Method not implemented.");
  }
  delete(id: number): boolean {
    throw new Error("Method not implemented.");
  }
  get(id: number): any[] {
    throw new Error("Method not implemented.");
  }
}

// 操作信息表 定义一个Info类和数据表映射
class Info {
  name: string | undefined
  password: string | undefined
}
let info = new Info()
info.name = '童雪枫'
info.password = '123456'

let oMysql = new Mysqldb<Info>()
oMysql.add(info) 
// Object { name: "童雪枫", password: "123456" }
```

## 8.3 命名空间

```typescript
-------------------------------------------------------命名空间.ts----------------------------------------------------------------
/*
命名空间:

    在代码量较大的情况下，为了避免各种变量命名相冲突，可将相似功能的函数、类、接口等放置到命名空间内

    同Java的包、.Net的命名空间一样，TypeScript的命名空间可以将代码包裹起来，只对外暴露需要在外部访问的对象。命名空间内的对象通过export关键字对外暴露。


命名空间和模块的区别：

    命名空间：内部模块，主要用于组织代码，避免命名冲突。

    模    块：ts的外部模块的简称，侧重代码的复用，一个模块里可能会有多个命名空间。

*/
import {A, B} from './modules/animal'
var dog = new A.Dog('修勾')
var cat=new B.Dog('小花')
dog.eat() // 修勾 在吃狗粮
cat.eat() // 小花 在吃狗粮。
---------------------------------------------------./modules/animal.ts----------------------------------------------------------
export namespace A{
  interface Animal {
      name: string;
      eat(): void;
  }
  export class Dog implements Animal {
      name: string;
      constructor(theName: string) {
          this.name = theName;
      }

      eat() {
          console.log(`${this.name} 在吃狗粮。`);
      }
  }

  export class Cat implements Animal {
      name: string;
      constructor(theName: string) {
          this.name = theName;
      }

      eat() {
          console.log(`${this.name} 吃猫粮。`);
      }
  }   

}

export namespace B{
  interface Animal {
      name: string;
      eat(): void;
  }
  export class Dog implements Animal {
      name: string;
      constructor(theName: string) {
          this.name = theName;
      }

      eat() {
          console.log(`${this.name} 在吃狗粮。`);
      }
  }

  export class Cat implements Animal {
      name: string;
      constructor(theName: string) {
          this.name = theName;
      }

      eat() {
          console.log(`${this.name} 在吃猫粮。`);
      }
  }   

}
```

## 8.4 装饰器

```typescript
* 装饰器:装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，属性或参数上，可以修改类的行为。
* 通俗的讲装饰器就是一个方法，可以注入到类、方法、属性参数上来扩展类、属性、方法、参数的功能。
* 常见的装饰器有：类装饰器、属性装饰器、方法装饰器、参数装饰器
* 装饰器的写法：普通装饰器（无法传参） 、 装饰器工厂（可传参）
* 装饰器是过去几年中js最大的成就之一，已是Es7的标准特性之一
```

### 8.4.1 类装饰器

```
类装饰器在类声明之前被声明（紧靠着类声明）。 类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。 传入一个参数
```

#### 类装饰器：普通装饰器（无法传参）

```typescript
function logClass(params:any){
  console.log(params);
  // params 就是当前类
  params.prototype.apiUrl='动态扩展的属性';
  params.prototype.run=function(){
    console.log('我是一个run方法');
  }
}

@logClass
class HttpClient{
  constructor(){
  }
  getData(){
  
  }
}
var http:any=new HttpClient();
console.log(http.apiUrl);
http.run();
```

#### 类装饰器:装饰器工厂（可传参）

```typescript
function logClass(params:string){
  return function(target:any){
	console.log(target);
	console.log(params);
	target.prototype.apiUrl=params;
  }
}

@logClass('http://www.itying.com/api')
class HttpClient{
  constructor(){
  }
  getData(){
  
  }
}

var http:any=new HttpClient();
console.log(http.apiUrl);
```

#### 例子

```typescript
下面是一个重载构造函数的例子。

类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。

如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。

function logClass(target:any){
  console.log(target);
  return class extends target{
	apiUrl:any='我是修改后的数据';
	getData(){
		this.apiUrl=this.apiUrl+'----';
		console.log(this.apiUrl);
	}
  }
}


@logClass
class HttpClient{
  public apiUrl:string | undefined;
  constructor(){
	this.apiUrl='我是构造函数里面的apiUrl';
    }
  getData(){
    console.log(this.apiUrl);
  }
}

var http=new HttpClient();
http.getData();
```

### 8.4.2 属性装饰器

```typescript
属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数：
1、对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
2、成员的名字。
//类装饰器  

function logClass(params:string){
  return function(target:any){
    console.log(target);
    console.log(params);       
  }
}

//属性装饰器

function logProperty(params:any){
  return function(target:any,attr:any){
    console.log(target);
    console.log(attr);
    target[attr]=params;
  }
}
@logClass('xxxx')
class HttpClient{
  @logProperty('http://itying.com')
  public url:any |undefined;
  constructor(){
  }
  getData(){
    console.log(this.url);
  }
}
var http=new HttpClient();
http.getData();
```

### 8.4.3 方法装饰器

```typescript
它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义。

方法装饰会在运行时传入下列3个参数：
1、对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
2、成员的名字。
3、成员的属性描述符。

    //方法装饰器一

function get(params:any){
  return function(target:any,methodName:any,desc:any){
    console.log(target);
    console.log(methodName);
    console.log(desc);
    target.apiUrl='xxxx';
    target.run=function(){
      console.log('run');
    }
  }
}

class HttpClient{  
  public url:any |undefined;
  constructor(){
  }
  @get('http://www.itying,com')
  getData(){
    console.log(this.url);
  }
}

var http:any=new HttpClient();
console.log(http.apiUrl);
http.run();

//方法装饰器二
function get(params:any){
  return function(target:any,methodName:any,desc:any){
    console.log(target);
    console.log(methodName);
    console.log(desc.value);       
    //修改装饰器的方法  把装饰器方法里面传入的所有参数改为string类型

    //1、保存当前的方法
    var oMethod=desc.value;
    desc.value=function(...args:any[]){                
      args=args.map((value)=>{
        return String(value);
      })
      oMethod.apply(this,args);
    }
  }
}

class HttpClient{  
  public url:any |undefined;
  constructor(){
  }
  @get('http://www.itying,com')
  getData(...args:any[]){
    console.log(args);
    console.log('我是getData里面的方法');
  }
}

var http=new HttpClient();
http.getData(123,'xxx');
```

### 8.4.4 方法参数装饰器

```typescript
参数装饰器表达式会在运行时当作函数被调用，可以使用参数装饰器为类的原型增加一些元素数据 ，传入下列3个参数：

1、对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
2、方法的名字。
3、参数在函数参数列表中的索引。
function logParams(params:any){
  return function(target:any,methodName:any,paramsIndex:any){
    console.log(params);
    console.log(target);
    console.log(methodName);
    console.log(paramsIndex);
    target.apiUrl=params;
  }   
}

class HttpClient{  
  public url:any |undefined;
  constructor(){
  }           
  getData(@logParams('xxxxx') uuid:any){               
    console.log(uuid);
  }
 }
var http:any = new HttpClient();
http.getData(123456);
console.log( http.apiUrl);
```

### 8.4.5 装饰器执行顺序

```typescript
属性 > 方法 > 方法参数 > 类
// 如果有多个同样的装饰器，它会先执行后面的

function logClass1(params:string){
  return function(target:any){
    console.log('类装饰器1')
  }
}

function logClass2(params:string){
  return function(target:any){
    console.log('类装饰器2')
  }
}

function logAttribute1(params?:string){
  return function(target:any,attrName:any){
    console.log('属性装饰器1')
  }
}

function logAttribute2(params?:string){
  return function(target:any,attrName:any){
    console.log('属性装饰器2')
  }
}

function logMethod1(params?:string){
  return function(target:any,attrName:any,desc:any){
    console.log('方法装饰器1')
  }
}
function logMethod2(params?:string){
  return function(target:any,attrName:any,desc:any){
    console.log('方法装饰器2')
  }
}


function logParams1(params?:string){
  return function(target:any,attrName:any,desc:any){
    console.log('方法参数装饰器1')
  }
}

function logParams2(params?:string){
  return function(target:any,attrName:any,desc:any){
    console.log('方法参数装饰器2')
  }
}


@logClass1('http://www.itying.com/api')
@logClass2('xxxx')
class HttpClient{
  @logAttribute1()
  @logAttribute2()
  public apiUrl:string | undefined;
  constructor(){
  }

  @logMethod1()
  @logMethod2()
  getData(){
      return true;
  }

  setData(@logParams1() attr1:any,@logParams2() attr2:any,){

  }
}

var http:any=new HttpClient();
// 打印结果：
/* 
	属性装饰器2
	属性装饰器1
	方法装饰器2
	方法装饰器1
	方法参数装饰器2
	方法参数装饰器1
	类装饰器2
	类装饰器1
*/
```

## 8.5 tsconfig.json

### 8.5.1 介绍

```
tsconfig.json 是 TypeScript 项目的配置文件。如果一个目录下存在一个 tsconfig.json 文件，那么往往意味着这个目录就是 TypeScript 项目的根目录。
tsconfig.json 包含 TypeScript 编译的相关配置，通过更改编译配置项，我们可以让 TypeScript 编译出 ES6、ES5、node 的代码。
```

### 8.5.2 重要字段

```json
{
  "files" : ...,
  "compilerOptions" : {...},
  "include" : ...,
  "exclude" : ...
}
* files - 设置要编译的文件的名称；
* include - 设置需要进行编译的文件，支持路径模式匹配；
* exclude - 设置无需进行编译的文件，支持路径模式匹配；
* compilerOptions - 设置与编译流程相关的选项。
```

### 8.5.3 compilerOptions 选项

```json
{
  "compilerOptions": {
  
    /* 基本选项 */
    "target": "es5",                       // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES6'/'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'
    "module": "commonjs",                  // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'
    "lib": [],                             // 指定要包含在编译中的库文件
    "allowJs": true,                       // 允许编译 javascript 文件
    "checkJs": true,                       // 报告 javascript 文件中的错误
    "jsx": "preserve",                     // 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react'
    "declaration": true,                   // 生成相应的 '.d.ts' 文件
    "sourceMap": true,                     // 生成相应的 '.map' 文件
    "outFile": "./",                       // 将输出文件合并为一个文件
    "outDir": "./",                        // 指定输出目录
    "rootDir": "./",                       // 用来控制输出目录结构 --outDir.
    "removeComments": true,                // 删除编译后的所有的注释
    "noEmit": true,                        // 不生成输出文件
    "importHelpers": true,                 // 从 tslib 导入辅助工具函数
    "isolatedModules": true,               // 将每个文件做为单独的模块 （与 'ts.transpileModule' 类似）.

    /* 严格的类型检查选项 */
    "strict": true,                        // 启用所有严格类型检查选项
    "noImplicitAny": true,                 // 在表达式和声明上有隐含的 any类型时报错
    "strictNullChecks": true,              // 启用严格的 null 检查
    "noImplicitThis": true,                // 当 this 表达式值为 any 类型的时候，生成一个错误
    "alwaysStrict": true,                  // 以严格模式检查每个模块，并在每个文件里加入 'use strict'

    /* 额外的检查 */
    "noUnusedLocals": true,                // 有未使用的变量时，抛出错误
    "noUnusedParameters": true,            // 有未使用的参数时，抛出错误
    "noImplicitReturns": true,             // 并不是所有函数里的代码都有返回值时，抛出错误
    "noFallthroughCasesInSwitch": true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）

    /* 模块解析选项 */
    "moduleResolution": "node",            // 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6)
    "baseUrl": "./",                       // 用于解析非相对模块名称的基目录
    "paths": {},                           // 模块名到基于 baseUrl 的路径映射的列表
    "rootDirs": [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容
    "typeRoots": [],                       // 包含类型声明的文件列表
    "types": [],                           // 需要包含的类型声明文件名列表
    "allowSyntheticDefaultImports": true,  // 允许从没有设置默认导出的模块中默认导入。

    /* Source Map Options */
    "sourceRoot": "./",                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置
    "mapRoot": "./",                       // 指定调试器应该找到映射文件而不是生成文件的位置
    "inlineSourceMap": true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件
    "inlineSources": true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性

    /* 其他选项 */
    "experimentalDecorators": true,        // 启用装饰器
    "emitDecoratorMetadata": true          // 为装饰器提供元数据的支持
  }
}

```

## 8.6 编写高效ts代码

### 8.6.1 减少重复代码

```typescript
// 对于刚接触 TypeScript 的小伙伴来说，在定义接口时，可能一不小心会出现以下类似的重复代码。比如：
interface Person {
  firstName: string;
  lastName: string;
}

interface PersonWithBirthDate {
  firstName: string;
  lastName: string;
  birth: Date;
}
/* 
很明显，相对于 Person 接口来说，PersonWithBirthDate 接口只是多了一个 birth 属性，其他的属性跟 Person 接口是一样的。那么如何避免出现例子中的重复代码呢？要解决这个问题，可以利用 extends 关键字：
*/
interface Person { 
  firstName: string; 
  lastName: string;
}

interface PersonWithBirthDate extends Person { 
  birth: Date;
}

// 也可以使用交叉运算符（&）：

type PersonWithBirthDate = Person & { birth: Date };

// 另外，有时候你可能还会发现自己想要定义一个类型来匹配一个初始配置对象的「形状」，比如：

const INIT_OPTIONS = {
  width: 640,
  height: 480,
  color: "#00FF00",
  label: "VGA",
};

interface Options {
  width: number;
  height: number;
  color: string;
  label: string;
}

// 其实，对于 Options 接口来说，你也可以使用 typeof 操作符来快速获取配置对象的「形状」：

type Options = typeof INIT_OPTIONS;

// 在实际的开发过程中，重复的类型并不总是那么容易被发现。有时它们会被语法所掩盖。比如有多个函数拥有相同的类型签名：

function get(url: string, opts: Options): Promise<Response> { /* ... */ } 
function post(url: string, opts: Options): Promise<Response> { /* ... */ }

// 对于上面的 get 和 post 方法，为了避免重复的代码，你可以提取统一的类型签名：

type HTTPFunction = (url: string, opts: Options) => Promise<Response>; 
const get: HTTPFunction = (url, opts) => { /* ... */ };
const post: HTTPFunction = (url, opts) => { /* ... */ };
```

### 8.6.2 使用更精确的类型代替字符串类型

```typescript
// 假设你正在构建一个音乐集，并希望为专辑定义一个类型。这时你可以使用 interface 关键字来定义一个 Album 类型：

interface Album {
  artist: string; // 艺术家
  title: string; // 专辑标题
  releaseDate: string; // 发行日期：YYYY-MM-DD
  recordingType: string; // 录制类型："live" 或 "studio"
}

/* 
对于 Album 类型，你希望 releaseDate 属性值的格式为 YYYY-MM-DD，而 recordingType 属性值的范围为 live 或 studio。但因为接口中 releaseDate 和 recordingType 属性的类型都是字符串，所以在使用 Album 接口时，可能会出现以下问题：
*/
const dangerous: Album = {
  artist: "Michael Jackson",
  title: "Dangerous",
  releaseDate: "November 31, 1991", // 与预期格式不匹配
  recordingType: "Studio", // 与预期格式不匹配
};
/*
虽然 releaseDate 和 recordingType 的值与预期的格式不匹配，但此时 TypeScript 编译器并不能发现该问题。为了解决这个问题，你应该为 releaseDate 和 recordingType 属性定义更精确的类型，比如这样：
*/
interface Album {
  artist: string; // 艺术家
  title: string; // 专辑标题
  releaseDate: Date; // 发行日期：YYYY-MM-DD
  recordingType: "studio" | "live"; // 录制类型："live" 或 "studio"
}

// 重新定义 Album 接口之后，对于前面的赋值语句，TypeScript 编译器就会提示以下异常信息：

const dangerous: Album = {
  artist: "Michael Jackson",
  title: "Dangerous",
  // 不能将类型“string”分配给类型“Date”。ts(2322)
  releaseDate: "November 31, 1991", // Error
  // 不能将类型“"Studio"”分配给类型“"studio" | "live"”。ts(2322)\
  recordingType: "Studio", // Error
};

// 为了解决上面的问题，你需要为 releaseDate 和 recordingType 属性设置正确的类型，比如这样:

const dangerous: Album = {
  artist: "Michael Jackson",
  title: "Dangerous",
  releaseDate: new Date("1991-11-31"),
  recordingType: "studio",
};
```

### 8.6.3 定义的类型总是表示有效的状态

```typescript
// 假设你正在构建一个允许用户指定页码，然后加载并显示该页面对应内容的 Web 应用程序。首先，你可能会先定义 State 对象：
interface State {
  pageContent: string;
  isLoading: boolean;
  errorMsg?: string;
}

// 接着你会定义一个 renderPage 函数，用来渲染页面：

function renderPage(state: State) {
  if (state.errorMsg) {
    return `呜呜呜，加载页面出现异常了...${state.errorMsg}`;
  } else if (state.isLoading) {
    return `页面加载中~~~`;
  }
  return `<div>${state.pageContent}</div>`;
}
console.log(renderPage({isLoading: true, pageContent: ""})); // 输出结果：页面加载中~~~
console.log(renderPage({isLoading: false, pageContent: "大家好呀"})); // 输出结果：<div>大家好</div>

// 创建好 renderPage 函数，你可以继续定义一个 changePage 函数，用于根据页码获取对应的页面数据：

async function changePage(state: State, newPage: string) {
  state.isLoading = true;
  try {
    const response = await fetch(getUrlForPage(newPage));
    if (!response.ok) {
      throw new Error(`Unable to load ${newPage}: ${response.statusText}`);
    }
    const text = await response.text();
    state.isLoading = false;
    state.pageContent = text;
  } catch (e) {
    state.errorMsg = "" + e;
  }
}
/*
对于以上的 changePage 函数，它存在以下问题：
* 在 catch 语句中，未把 state.isLoading 的状态设置为 false；
* 未及时清理 state.errorMsg 的值，因此如果之前的请求失败，那么你将继续看到错误消息，而不是加载消息。

出现上述问题的原因是，前面定义的 State 类型允许同时设置 isLoading 和 errorMsg 的值，尽管这是一种无效的状态。针对这个问题，你可以考虑引入可辨识联合类型来定义不同的页面请求状态：
*/
interface RequestPending {
  state: "pending";
}

interface RequestError {
  state: "error";
  errorMsg: string;
}

interface RequestSuccess {
  state: "ok";
  pageContent: string;
}

type RequestState = RequestPending | RequestError | RequestSuccess;

interface State {
  currentPage: string;
  requests: { [page: string]: RequestState };
}
/* 
在以上代码中，通过使用可辨识联合类型分别定义了 3 种不同的请求状态，这样就可以很容易的区分出不同的请求状态，从而让业务逻辑处理更加清晰。接下来，需要基于更新后的 State 类型，来分别更新一下前面创建的 renderPage 和 changePage 函数：
*/
// 更新后的 renderPage 函数
function renderPage(state: State) {
  const { currentPage } = state;
  const requestState = state.requests[currentPage];
  switch (requestState.state) {
    case "pending":
      return `页面加载中~~~`;
    case "error":
      return `呜呜呜，加载第${currentPage}页出现异常了...${requestState.errorMsg}`;
    case "ok":
      `<div>第${currentPage}页的内容：${requestState.pageContent}</div>`;
  }
}
// 更新后的 changePage 函数
async function changePage(state: State, newPage: string) {
  state.requests[newPage] = { state: "pending" };
  state.currentPage = newPage;
  try {
    const response = await fetch(getUrlForPage(newPage));
    if (!response.ok) {
      throw new Error(`无法正常加载页面 ${newPage}: ${response.statusText}`);
    }
    const pageContent = await response.text();
    state.requests[newPage] = { state: "ok", pageContent };
  } catch (e) {
    state.requests[newPage] = { state: "error", errorMsg: "" + e };
  }
}
/*
在 changePage 函数中，会根据不同的情形设置不同的请求状态，而不同的请求状态会包含不同的信息。这样 renderPage 函数就可以根据统一的 state 属性值来进行相应的处理。因此，通过使用可辨识联合类型，让请求的每种状态都是有效的状态，不会出现无效状态的问题。
*/
```



# 9. Vue 3

TS + Vue3 尚硅谷文档

https://24kcs.github.io/vue3_study/00_%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D.html

## 9.1 Compositon API

### 1. Composition API（主要）

#### 1) setup

+ 新的option, 所有的组合API函数都在此使用, 只在初始化时执行一次
+ 函数如果返回对象, 对象中的属性或方法, 模板中可以直接使用

#### 2) ref

+ 作用: 定义一个数据的响应式

+ 语法: const xxx = ref(initValue):
  - 创建一个包含响应式数据的引用(reference)对象
  - js中操作数据: xxx.value
  - 模板中操作数据: 不需要.value
  
+ 一般用来定义一个基本类型的响应式数据
```vue
<template>
  <h2>{{count}}</h2>
  <hr>
  <button @click="update">更新</button>
</template>

<script>
import {
  ref
} from 'vue'
export default {
  /* 在Vue3中依然可以使用data和methods配置, 但建议使用其新语法实现 */
  // data () {
  //   return {
  //     count: 0
  //   }
  // },
  // methods: {
  //   update () {
  //     this.count++
  //   }
  // }

  /* 使用vue3的composition API */
  setup () {

    // 定义响应式数据 ref对象
    const count = ref(1)
    console.log(count)

    // 更新响应式数据的函数
    function update () {
      // alert('update')
      count.value = count.value + 1
    }

    return {
      count,
      update
    }
  }
}
</script>
```

#### 3) reactive

+ 作用: 定义多个数据的响应式
+ const proxy = reactive(obj): 接收一个普通对象然后返回该普通对象的响应式代理器对象
+ 响应式转换是“深层的”：会影响对象内部所有嵌套的属性
+ 内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据都是响应式的
```vue
<template>
  <h2>name: {{state.name}}</h2>
  <h2>age: {{state.age}}</h2>
  <h2>wife: {{state.wife}}</h2>
  <hr>
  <button @click="update">更新</button>
</template>

<script>
/* 
reactive: 
    作用: 定义多个数据的响应式
    const proxy = reactive(obj): 接收一个普通对象然后返回该普通对象的响应式代理器对象
    响应式转换是“深层的”：会影响对象内部所有嵌套的属性
    内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据都是响应式的
*/
import {
  reactive,
} from 'vue'
export default {
  setup () {
    /* 
    定义响应式数据对象
    */
    const state = reactive({
      name: 'tom',
      age: 25,
      wife: {
        name: 'marry',
        age: 22
      },
    })
    console.log(state, state.wife)

    const update = () => {
      state.name += '--'
      state.age += 1
      state.wife.name += '++'
      state.wife.age += 2
    }

    return {
      state,
      update,
    }
  }
}
</script>
```
#### 4) 比较Vue2与Vue3的响应式

##### Vue2的响应式：

+ 核心：
  - 对象: 通过defineProperty对对象的已有属性值的读取和修改进行劫持(监视/拦截)
  - 数组: 通过重写数组更新数组一系列更新元素的方法来实现元素修改的劫持
```vue
Object.defineProperty(data, 'count', {
    get () {}, 
    set () {}
})
```

+ 问题
  + 对象直接新添加的属性或删除已有属性, 界面不会自动更新
  + 直接通过下标替换元素或更新length, 界面不会自动更新 arr[1] = {}

##### Vue3的响应式：

+ 核心
  + 通过Proxy(代理): 拦截对data任意属性的任意(13种)操作, 包括属性值的读写, 属性的添加, 属性的删除等...
  + 通过 Reflect(反射): 动态对被代理对象的相应属性进行特定的操作
  + 文档:
    + https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy
    + https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect

```vue
new Proxy(data, {
	// 拦截读取属性值
    get (target, prop) {
    	return Reflect.get(target, prop)
    },
    // 拦截设置属性值或添加新属性
    set (target, prop, value) {
    	return Reflect.set(target, prop, value)
    },
    // 拦截删除属性
    deleteProperty (target, prop) {
    	return Reflect.deleteProperty(target, prop)
    }
})

proxy.name = 'tom'   
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Proxy 与 Reflect</title>
</head>
<body>
  <script>
    
    const user = {
      name: "John",
      age: 12
    };

    /* 
    proxyUser是代理对象, user是被代理对象
    后面所有的操作都是通过代理对象来操作被代理对象内部属性
    */
    const proxyUser = new Proxy(user, {

      get(target, prop) {
        console.log('劫持get()', prop)
        return Reflect.get(target, prop)
      },

      set(target, prop, val) {
        console.log('劫持set()', prop, val)
        return Reflect.set(target, prop, val); // (2)
      },

      deleteProperty (target, prop) {
        console.log('劫持delete属性', prop)
        return Reflect.deleteProperty(target, prop)
      }
    });
    // 读取属性值
    console.log(proxyUser===user)
    console.log(proxyUser.name, proxyUser.age)
    // 设置属性值
    proxyUser.name = 'bob'
    proxyUser.age = 13
    console.log(user)
    // 添加属性
    proxyUser.sex = '男'
    console.log(user)
    // 删除属性
    delete proxyUser.sex
    console.log(user)
  </script>
</body>
</html>
```

#### 5) setup细节

+ setup执行的时机
  + 在beforeCreate之前执行(一次), 此时组件对象还没有创建
  + this是undefined, 不能通过this来访问data/computed/methods / props
  + 其实所有的composition API相关回调函数中也都不可以访问

+ setup的返回值
  + 一般都返回一个对象: 为模板提供数据, 也就是模板中可以直接使用此对象中的所有属性/方法
  + 返回对象中的属性会与data函数返回对象的属性合并成为组件对象的属性
  + 返回对象中的方法会与methods中的方法合并成功组件对象的方法
  + 如果有重名, setup优先
  + 注意:
  + 一般不要混合使用: methods中可以访问setup提供的属性和方法, 但在setup方法中不能访问data和methods
  + setup不能是一个async函数: 因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性数据

+ setup的参数
  + setup(props, context) / setup(props, {attrs, slots, emit})
  + props: 包含props配置声明且传入了的所有属性的对象
  + attrs: 包含没有在props配置中声明的属性的对象, 相当于 this.$attrs
  + slots: 包含所有传入的插槽内容的对象, 相当于 this.$slots
  + emit: 用来分发自定义事件的函数, 相当于 this.$emit

```vue
<template>
  <h2>App</h2>
  <p>msg: {{msg}}</p>
  <button @click="fn('--')">更新</button>

  <child :msg="msg" msg2="cba" @fn="fn"/>
</template>

<script lang="ts">
import {
  reactive,
  ref,
} from 'vue'
import child from './child.vue'

export default {

  components: {
    child
  },

  setup () {
    const msg = ref('abc')

    function fn (content: string) {
      msg.value += content
    }
    return {
      msg,
      fn
    }
  }
}
</script>
```

```vue
<template>
  <div>
    <h3>{{n}}</h3>
    <h3>{{m}}</h3>

    <h3>msg: {{msg}}</h3>
    <h3>msg2: {{$attrs.msg2}}</h3>

    <slot name="xxx"></slot>

    <button @click="update">更新</button>
  </div>
</template>

<script lang="ts">

import {
  ref,
  defineComponent
} from 'vue'

export default defineComponent({
  name: 'child',

  props: ['msg'],

  emits: ['fn'], // 可选的, 声明了更利于程序员阅读, 且可以对分发的事件数据进行校验

  data () {
    console.log('data', this)
    return {
      // n: 1
    }
  },

  beforeCreate () {
    console.log('beforeCreate', this)
  },

  methods: {
    // update () {
    //   this.n++
    //   this.m++
    // }
  },

  // setup (props, context) {
  setup (props, {attrs, emit, slots}) {

    console.log('setup', this)
    console.log(props.msg, attrs.msg2, slots, emit)

    const m = ref(2)
    const n = ref(3)

    function update () {
      // console.log('--', this)
      // this.n += 2 
      // this.m += 2

      m.value += 2
      n.value += 2

      // 分发自定义事件
      emit('fn', '++')
    }

    return {
      m,
      n,
      update,
    }
  },
})
</script>
```

#### 6) reactive与ref细节

+ 是Vue3的 composition API中2个最重要的响应式API
+ ref用来处理基本类型数据, reactive用来处理对象(递归深度响应式)
+ 如果用ref对象/数组, 内部会自动将对象/数组转换为reactive的代理对象
+ ref内部: 通过给value属性添加getter/setter来实现对数据的劫持
+ reactive内部: 通过使用Proxy来实现对对象内部所有数据的劫持, 并通过Reflect操作对象内部数据
+ ref的数据操作: 在js中要.value, 在模板中不需要(内部解析模板时会自动添加.value)

```vue
<template>
  <h2>App</h2>
  <p>m1: {{m1}}</p>
  <p>m2: {{m2}}</p>
  <p>m3: {{m3}}</p>
  <button @click="update">更新</button>
</template>

<script lang="ts">
import {
  reactive,
  ref
} from 'vue'

export default {

  setup () {
    const m1 = ref('abc')
    const m2 = reactive({x: 1, y: {z: 'abc'}})

    // 使用ref处理对象  ==> 对象会被自动reactive为proxy对象
    const m3 = ref({a1: 2, a2: {a3: 'abc'}})
    console.log(m1, m2, m3)
    console.log(m3.value.a2) // 也是一个proxy对象

    function update() {
      m1.value += '--'
      m2.x += 1
      m2.y.z += '++'

      m3.value = {a1: 3, a2: {a3: 'abc---'}}
      m3.value.a2.a3 += '==' // reactive对对象进行了深度数据劫持
      console.log(m3.value.a2)
    }

    return {
      m1,
      m2,
      m3,
      update
    }
  }
}
</script>
```

#### 7) 计算属性与监视

- computed函数:
  - 与computed配置功能一致
  - 只有getter
  - 有getter和setter
- watch函数
  - 与watch配置功能一致
  - 监视指定的一个或多个响应式数据, 一旦数据变化, 就自动执行监视回调
  - 默认初始时不执行回调, 但可以通过配置immediate为true, 来指定初始时立即执行第一次
  - 通过配置deep为true, 来指定深度监视
- watchEffect函数
  - 不用直接指定要监视的数据, 回调函数中使用的哪些响应式数据就监视哪些响应式数据
  - 默认初始时就会执行第一次, 从而可以收集需要监视的数据
  - 监视数据发生变化时回调

```vue
<template>
  <h2>App</h2>
  fistName: <input v-model="user.firstName"/><br>
  lastName: <input v-model="user.lastName"/><br>
  fullName1: <input v-model="fullName1"/><br>
  fullName2: <input v-model="fullName2"><br>
  fullName3: <input v-model="fullName3"><br>

</template>

<script lang="ts">
/*
计算属性与监视
1. computed函数: 
  与computed配置功能一致
  只有getter
  有getter和setter
2. watch函数
  与watch配置功能一致
  监视指定的一个或多个响应式数据, 一旦数据变化, 就自动执行监视回调
  默认初始时不执行回调, 但可以通过配置immediate为true, 来指定初始时立即执行第一次
  通过配置deep为true, 来指定深度监视
3. watchEffect函数
  不用直接指定要监视的数据, 回调函数中使用的哪些响应式数据就监视哪些响应式数据
  默认初始时就会执行第一次, 从而可以收集需要监视的数据
  监视数据发生变化时回调
*/

import {
  reactive,
  ref,
  computed,
  watch,
  watchEffect
} from 'vue'

export default {

  setup () {
    const user = reactive({
      firstName: 'A',
      lastName: 'B'
    })

    // 只有getter的计算属性
    const fullName1 = computed(() => {
      console.log('fullName1')
      return user.firstName + '-' + user.lastName
    })

    // 有getter与setter的计算属性
    const fullName2 = computed({
      get () {
        console.log('fullName2 get')
        return user.firstName + '-' + user.lastName
      },

      set (value: string) {
        console.log('fullName2 set')
        const names = value.split('-')
        user.firstName = names[0]
        user.lastName = names[1]
      }
    })

    const fullName3 = ref('')

    /* 
    watchEffect: 监视所有回调中使用的数据
    */
    /* 
    watchEffect(() => {
      console.log('watchEffect')
      fullName3.value = user.firstName + '-' + user.lastName
    }) 
    */

    /* 
    使用watch的2个特性:
      深度监视
      初始化立即执行
    */
    watch(user, () => {
      fullName3.value = user.firstName + '-' + user.lastName
    }, {
      immediate: true,  // 是否初始化立即执行一次, 默认是false
      deep: true, // 是否是深度监视, 默认是false
    })

    /* 
    watch一个数据
      默认在数据发生改变时执行回调
    */
    watch(fullName3, (value) => {
      console.log('watch')
      const names = value.split('-')
      user.firstName = names[0]
      user.lastName = names[1]
    })

    /* 
    watch多个数据: 
      使用数组来指定
      如果是ref对象, 直接指定
      如果是reactive对象中的属性,  必须通过函数来指定
    */
    watch([() => user.firstName, () => user.lastName, fullName3], (values) => {
      console.log('监视多个数据', values)
    })

    return {
      user,
      fullName1,
      fullName2,
      fullName3
    }
  }
}
</script>
```

#### 8) 生命周期

##### vue2.x的生命周期:

https://cn.vuejs.org/images/lifecycle.png

##### vue3的生命周期:

https://v3.cn.vuejs.org/images/lifecycle.svg

##### 与 2.x 版本生命周期相对应的组合式 API

##### 新增的钩子函数

组合式 API 还提供了以下调试钩子函数：

- onRenderTracked
- onRenderTriggered

```vue
<template>
<div class="about">
  <h2>msg: {{msg}}</h2>
  <hr>
  <button @click="update">更新</button>
</div>
</template>

<script lang="ts">
import {
  ref,
  onMounted,
  onUpdated,
  onUnmounted, 
  onBeforeMount, 
  onBeforeUpdate,
  onBeforeUnmount
} from "vue"

export default {
  beforeCreate () {
    console.log('beforeCreate()')
  },

  created () {
    console.log('created')
  },

  beforeMount () {
    console.log('beforeMount')
  },

  mounted () {
    console.log('mounted')
  },

  beforeUpdate () {
    console.log('beforeUpdate')
  },

  updated () {
    console.log('updated')
  },

  beforeUnmount () {
    console.log('beforeUnmount')
  },

  unmounted () {
     console.log('unmounted')
  },
  

  setup() {
    
    const msg = ref('abc')

    const update = () => {
      msg.value += '--'
    }

    onBeforeMount(() => {
      console.log('--onBeforeMount')
    })

    onMounted(() => {
      console.log('--onMounted')
    })

    onBeforeUpdate(() => {
      console.log('--onBeforeUpdate')
    })

    onUpdated(() => {
      console.log('--onUpdated')
    })

    onBeforeUnmount(() => {
      console.log('--onBeforeUnmount')
    })

    onUnmounted(() => {
      console.log('--onUnmounted')
    })
    
    return {
      msg,
      update
    }
  }
}
</script>
```

```vue
<template>
  <h2>App</h2>
  <button @click="isShow=!isShow">切换</button>
  <hr>
  <Child v-if="isShow"/>
</template>

<script lang="ts">
import Child from './Child.vue'
export default {

  data () {
    return {
      isShow: true
    }
  },

  components: {
    Child
  }
}
</script>
```

#### 9) 自定义hook函数

- 使用Vue3的组合API封装的可复用的功能函数

- 自定义hook的作用类似于vue2中的mixin技术

- 自定义Hook的优势: 很清楚复用功能代码的来源, 更清楚易懂

- 需求1: 收集用户鼠标点击的页面坐标

  hooks/useMousePosition.ts

  ```js
  import { ref, onMounted, onUnmounted } from 'vue'
  /* 
  收集用户鼠标点击的页面坐标
  */
  export default function useMousePosition () {
    // 初始化坐标数据
    const x = ref(-1)
    const y = ref(-1)
  
    // 用于收集点击事件坐标的函数
    const updatePosition = (e: MouseEvent) => {
      x.value = e.pageX
      y.value = e.pageY
    }
  
    // 挂载后绑定点击监听
    onMounted(() => {
      document.addEventListener('click', updatePosition)
    })
  
    // 卸载前解绑点击监听
    onUnmounted(() => {
      document.removeEventListener('click', updatePosition)
    })
  
    return {x, y}
  }
  ```

  ```vue
  <template>
  <div>
    <h2>x: {{x}}, y: {{y}}</h2>
  </div>
  </template>
  
  <script>
  
  import {
    ref
  } from "vue"
  /* 
  在组件中引入并使用自定义hook
  自定义hook的作用类似于vue2中的mixin技术
  自定义Hook的优势: 很清楚复用功能代码的来源, 更清楚易懂
  */
  import useMousePosition from './hooks/useMousePosition'
  
  export default {
    setup() {
  
      const {x, y} = useMousePosition()
  
      return {
        x,
        y,
      }
    }
  }
  </script>
  ```

- 利用TS泛型强化类型检查

- 需求2: 封装发ajax请求的hook函数

  hooks/useRequest.ts

  ```ts
  import { ref } from 'vue'
  import axios from 'axios'
  
  /* 
  使用axios发送异步ajax请求
  */
  export default function useUrlLoader<T>(url: string) {
  
    const result = ref<T | null>(null)
    const loading = ref(true)
    const errorMsg = ref(null)
  
    axios.get(url)
      .then(response => {
        loading.value = false
        result.value = response.data
      })
      .catch(e => {
        loading.value = false
        errorMsg.value = e.message || '未知错误'
      })
  
    return {
      loading,
      result,
      errorMsg,
    }
  }
  ```

  ```vue
  <template>
  <div class="about">
    <h2 v-if="loading">LOADING...</h2>
    <h2 v-else-if="errorMsg">{{errorMsg}}</h2>
    <!-- <ul v-else>
      <li>id: {{result.id}}</li>
      <li>name: {{result.name}}</li>
      <li>distance: {{result.distance}}</li>
    </ul> -->
  
    <ul v-for="p in result" :key="p.id">
      <li>id: {{p.id}}</li>
      <li>title: {{p.title}}</li>
      <li>price: {{p.price}}</li>
    </ul>
    <!-- <img v-if="result" :src="result[0].url" alt=""> -->
  </div>
  </template>
  
  <script lang="ts">
  import {
    watch
  } from "vue"
  import useRequest from './hooks/useRequest'
  
  // 地址数据接口
  interface AddressResult {
    id: number;
    name: string;
    distance: string;
  }
  
  // 产品数据接口
  interface ProductResult {
    id: string;
    title: string;
    price: number;
  }
  
  export default {
    setup() {
  
      // const {loading, result, errorMsg} = useRequest<AddressResult>('/data/address.json')
      const {loading, result, errorMsg} = useRequest<ProductResult[]>('/data/products.json')
  
      watch(result, () => {
        if (result.value) {
          console.log(result.value.length) // 有提示
        }
      })
  
      return {
        loading,
        result, 
        errorMsg
      }
    }
  }
  </script>
  ```

#### 10) toRefs

把一个响应式对象转换成普通对象，该普通对象的每个 property 都是一个 ref

应用: 当从合成函数返回响应式对象时，toRefs 非常有用，这样消费组件就可以在不丢失响应式的情况下对返回的对象进行分解使用

问题: reactive 对象取出的所有属性值都是非响应式的

解决: 利用 toRefs 可以将一个响应式 reactive 对象的所有原始属性转换为响应式的 ref 属性

```vue
<template>
  <h2>App</h2>
  <h3>foo: {{foo}}</h3>
  <h3>bar: {{bar}}</h3>
  <h3>foo2: {{foo2}}</h3>
  <h3>bar2: {{bar2}}</h3>


</template>

<script lang="ts">
import { reactive, toRefs } from 'vue'
/*
toRefs:
  将响应式对象中所有属性包装为ref对象, 并返回包含这些ref对象的普通对象
  应用: 当从合成函数返回响应式对象时，toRefs 非常有用，
        这样消费组件就可以在不丢失响应式的情况下对返回的对象进行分解使用
*/
export default {

  setup () {

    const state = reactive({
      foo: 'a',
      bar: 'b',
    })

    const stateAsRefs = toRefs(state)

    setTimeout(() => {
      state.foo += '++'
      state.bar += '++'
    }, 2000);

    const {foo2, bar2} = useReatureX()

    return {
      // ...state,
      ...stateAsRefs,
      foo2, 
      bar2
    }
  },
}

function useReatureX() {
  const state = reactive({
    foo2: 'a',
    bar2: 'b',
  })

  setTimeout(() => {
    state.foo2 += '++'
    state.bar2 += '++'
  }, 2000);

  return toRefs(state)
}

</script>
```

#### 11) ref获取元素

利用ref函数获取组件中的标签元素

功能需求: 让输入框自动获取焦点

```vue
<template>
  <h2>App</h2>
  <input type="text">---
  <input type="text" ref="inputRef">
</template>

<script lang="ts">
import { onMounted, ref } from 'vue'
/* 
ref获取元素: 利用ref函数获取组件中的标签元素
功能需求: 让输入框自动获取焦点
*/
export default {
  setup() {
    const inputRef = ref<HTMLElement|null>(null)

    onMounted(() => {
      inputRef.value && inputRef.value.focus()
    })

    return {
      inputRef
    }
  },
}
</script>
```

### 2. Composition API（其他）

#### 1) shallowReactive 与 shallowRef

- shallowReactive : 只处理了对象内最外层属性的响应式(也就是浅响应式)
- shallowRef: 只处理了value的响应式, 不进行对象的reactive处理
- 什么时候用浅响应式呢?
  - 一般情况下使用ref和reactive即可
  - 如果有一个对象数据, 结构比较深, 但变化时只是外层属性变化 ===> shallowReactive
  - 如果有一个对象数据, 后面会产生新的对象来替换 ===> shallowRef

```vue
<template>
  <h2>App</h2>

  <h3>m1: {{m1}}</h3>
  <h3>m2: {{m2}}</h3>
  <h3>m3: {{m3}}</h3>
  <h3>m4: {{m4}}</h3>

  <button @click="update">更新</button>
</template>

<script lang="ts">
import { reactive, ref, shallowReactive, shallowRef } from 'vue'
/* 
shallowReactive与shallowRef
  shallowReactive: 只处理了对象内最外层属性的响应式(也就是浅响应式)
  shallowRef: 只处理了value的响应式, 不进行对象的reactive处理
总结:
  reactive与ref实现的是深度响应式, 而shallowReactive与shallowRef是浅响应式
  什么时候用浅响应式呢?
    一般情况下使用ref和reactive即可,
    如果有一个对象数据, 结构比较深, 但变化时只是外层属性变化 ===> shallowReactive
    如果有一个对象数据, 后面会产生新的对象来替换 ===> shallowRef
*/

export default {

  setup () {

    const m1 = reactive({a: 1, b: {c: 2}})
    const m2 = shallowReactive({a: 1, b: {c: 2}})

    const m3 = ref({a: 1, b: {c: 2}})
    const m4 = shallowRef({a: 1, b: {c: 2}})

    const update = () => {
      // m1.b.c += 1
      // m2.b.c += 1

      // m3.value.a += 1
      m4.value.a += 1
    }

    return {
      m1,
      m2,
      m3,
      m4,
      update,
    }
  }
}
</script>
```

#### 2) readonly 与 shallowReadonly

- readonly:
  - 深度只读数据
  - 获取一个对象 (响应式或纯对象) 或 ref 并返回原始代理的只读代理。
  - 只读代理是深层的：访问的任何嵌套 property 也是只读的。
- shallowReadonly
  - 浅只读数据
  - 创建一个代理，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换
- 应用场景:
  - 在某些特定情况下, 我们可能不希望对数据进行更新的操作, 那就可以包装生成一个只读代理对象来读取数据, 而不能修改或删除

```vue
<template>
  <h2>App</h2>
  <h3>{{state}}</h3>
  <button @click="update">更新</button>
</template>

<script lang="ts">
import { reactive, readonly, shallowReadonly } from 'vue'
/*
readonly: 深度只读数据
  获取一个对象 (响应式或纯对象) 或 ref 并返回原始代理的只读代理。
  只读代理是深层的：访问的任何嵌套 property 也是只读的。
shallowReadonly: 浅只读数据
  创建一个代理，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换 
应用场景: 
  在某些特定情况下, 我们可能不希望对数据进行更新的操作, 那就可以包装生成一个只读代理对象来读取数据, 而不能修改或删除
*/

export default {

  setup () {

    const state = reactive({
      a: 1,
      b: {
        c: 2
      }
    })

    // const rState1 = readonly(state)
    const rState2 = shallowReadonly(state)

    const update = () => {
      // rState1.a++ // error
      // rState1.b.c++ // error

      // rState2.a++ // error
      rState2.b.c++
    }
    
    return {
      state,
      update
    }
  }
}
</script>
```

#### 3) toRaw 与 markRaw

- toRaw
  - 返回由 `reactive` 或 `readonly` 方法转换成响应式代理的普通对象。
  - 这是一个还原方法，可用于临时读取，访问不会被代理/跟踪，写入时也不会触发界面更新。
- markRaw
  - 标记一个对象，使其永远不会转换为代理。返回对象本身
  - 应用场景:
    - 有些值不应被设置为响应式的，例如复杂的第三方类实例或 Vue 组件对象。
    - 当渲染具有不可变数据源的大列表时，跳过代理转换可以提高性能。

```vue
<template>
  <h2>{{state}}</h2>
  <button @click="testToRaw">测试toRaw</button>
  <button @click="testMarkRaw">测试markRaw</button>
</template>

<script lang="ts">
/* 
toRaw: 得到reactive代理对象的目标数据对象
*/
import {
  markRaw,
  reactive, toRaw,
} from 'vue'
export default {
  setup () {
    const state = reactive<any>({
      name: 'tom',
      age: 25,
    })

    const testToRaw = () => {
      const user = toRaw(state)
      user.age++  // 界面不会更新

    }

    const testMarkRaw = () => {
      const likes = ['a', 'b']
      // state.likes = likes
      state.likes = markRaw(likes) // likes数组就不再是响应式的了
      setTimeout(() => {
        state.likes[0] += '--'
      }, 1000)
    }

    return {
      state,
      testToRaw,
      testMarkRaw,
    }
  }
}
</script>
```

#### 4) toRef

- 为源响应式对象上的某个属性创建一个 ref对象, 二者内部操作的是同一个数据值, 更新时二者是同步的
- 区别ref: 拷贝了一份新的数据值单独操作, 更新时相互不影响
- 应用: 当要将 某个prop 的 ref 传递给复合函数时，toRef 很有用

```vue
<template>
  <h2>App</h2>
  <p>{{state}}</p>
  <p>{{foo}}</p>
  <p>{{foo2}}</p>

  <button @click="update">更新</button>

  <Child :foo="foo"/>
</template>

<script lang="ts">
/*
toRef:
  为源响应式对象上的某个属性创建一个 ref对象, 二者内部操作的是同一个数据值, 更新时二者是同步的
  区别ref: 拷贝了一份新的数据值单独操作, 更新时相互不影响
  应用: 当要将某个 prop 的 ref 传递给复合函数时，toRef 很有用
*/

import {
  reactive,
  toRef,
  ref,
} from 'vue'
import Child from './Child.vue'

export default {

  setup () {

    const state = reactive({
      foo: 1,
      bar: 2
    })

    const foo = toRef(state, 'foo')
    const foo2 = ref(state.foo)

    const update = () => {
      state.foo++
      // foo.value++
      // foo2.value++  // foo和state中的数据不会更新
    }

    return {
      state,
      foo,
      foo2,
      update,
    }
  },

  components: {
    Child
  }
}
</script>
```

```vue
<template>
  <h2>Child</h2>
  <h3>{{foo}}</h3>
  <h3>{{length}}</h3>
</template>

<script lang="ts">
import { computed, defineComponent, Ref, toRef } from 'vue'

const component = defineComponent({
  props: {
    foo: {
      type: Number,
      require: true
    }
  },

  setup (props, context) {
    const length = useFeatureX(toRef(props, 'foo'))

    return {
      length
    }
  }
})

function useFeatureX(foo: Ref) {
  const lenth = computed(() => foo.value.length)

  return lenth
}

export default component
</script>
```

#### 5) customRef

- 创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制
- 需求: 使用 customRef 实现 debounce 的示例

```vue
<template>
  <h2>App</h2>
  <input v-model="keyword" placeholder="搜索关键字"/>
  <p>{{keyword}}</p>
</template>

<script lang="ts">
/*
customRef:
  创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制

需求: 
  使用 customRef 实现 debounce 的示例
*/

import {
  ref,
  customRef
} from 'vue'

export default {

  setup () {
    const keyword = useDebouncedRef('', 500)
    console.log(keyword)
    return {
      keyword
    }
  },
}

/* 
实现函数防抖的自定义ref
*/
function useDebouncedRef<T>(value: T, delay = 200) {
  let timeout: number
  return customRef((track, trigger) => {
    return {
      get() {
        // 告诉Vue追踪数据
        track()
        return value
      },
      set(newValue: T) {
        clearTimeout(timeout)
        timeout = setTimeout(() => {
          value = newValue
          // 告诉Vue去触发界面更新
          trigger()
        }, delay)
      }
    }
  })
}

</script>
```

#### 6) provide 与 inject

- provide`和`inject`提供依赖注入，功能类似 2.x 的`provide/inject
- 实现跨层级组件(祖孙)间通信

```vue
<template>
  <h1>父组件</h1>
  <p>当前颜色: {{color}}</p>
  <button @click="color='red'">红</button>
  <button @click="color='yellow'">黄</button>
  <button @click="color='blue'">蓝</button>
  
  <hr>
  <Son />
</template>

<script lang="ts">
import { provide, ref } from 'vue'
/* 
- provide` 和 `inject` 提供依赖注入，功能类似 2.x 的 `provide/inject
- 实现跨层级组件(祖孙)间通信
*/

import Son from './Son.vue'
export default {
  name: 'ProvideInject',
  components: {
    Son
  },
  setup() {
    
    const color = ref('red')

    provide('color', color)

    return {
      color
    }
  }
}
</script>
```

```vue
<template>
  <div>
    <h2>子组件</h2>
    <hr>
    <GrandSon />
  </div>
</template>

<script lang="ts">
import GrandSon from './GrandSon.vue'
export default {
  components: {
    GrandSon
  },
}
</script>
```

```vue
<template>
  <h3 :style="{color}">孙子组件: {{color}}</h3>
  
</template>

<script lang="ts">
import { inject } from 'vue'
export default {
  setup() {
    const color = inject('color')

    return {
      color
    }
  }
}
</script>
```

#### 7) 响应式数据的判断

- isRef: 检查一个值是否为一个 ref 对象
- isReactive: 检查一个对象是否是由 `reactive` 创建的响应式代理
- isReadonly: 检查一个对象是否是由 `readonly` 创建的只读代理
- isProxy: 检查一个对象是否是由 `reactive` 或者 `readonly` 方法创建的代理

### 3. 手写组合API

#### 1) shallowReactive 与 reactive

```js
// 只实现劫持,不实现界面更新
// shallowReactive(浅劫持\浅监视\浅响应式) 和 reactive(深劫持)

// 定义Handler处理器对象
const reactiveHandler = {
  // 获取属性值
  get (target, prop) {
    const res = Reflect.get(target, prop)
    console.log('拦截了读取数据', prop, res)
    return res
  },

  // 修改属性值/添加属性
  set (target, prop, value) {
    const res = Reflect.set(target, prop, value)
    console.log('拦截了修改数据或添加属性', prop, value)
    return res
  },

  // 删除属性
  deleteProperty (target, prop) {
    const res = Reflect.deleteProperty(target, prop)
    console.log('拦截了删除数据', prop)
    return res
  },
}

/* 
  自定义shallowReactive,内部传入目标对象
*/
function shallowReactive(target) {
  // 判断当前目标对象是否为object类型(对象/数组)
  if (target && typeof target === 'object') {
    return new Proxy(target, reactiveHandler)
  }

  // 如果是基本类型,直接返回
  return target
}

/* 
  自定义reactive,传入要给目标对象
*/
function reactive(target) {
  // 判断当前目标对象是否为object类型(对象/数组)
  if (target && typeof target === 'object') {
    // 对数组或对象中的所有数据进行reactive的递归深度处理
    // 判断当前数据是否为数组
    if (Array.isArray(target)) {
      target.forEach((item, index) => {
        target[index] = reactive(item)
      })
    } else {
      // 再判断当前数据是不是对象
      Object.keys(target).forEach(key => {
        target[key] = reactive(target[key])
      })
    }
    return new Proxy(target, reactiveHandler)
  }

  // 如果是基本类型,直接返回
  return target
}
---------------------------------------------------------------------------------------
const proxyUser1 = shallowReactive({
    name: '小黑',
    car: {
        color: 'blue'
    }
})
// proxyUser1.name = '小绿' 
// 拦截了修改数据或添加属性 name 小绿

// proxyUser1.name += '=' 
// 拦截了读取数据 name 小黑  
// 拦截了修改数据或添加属性 name 小黑=

// proxyUser1.car.color += '='
// 没拦截到写数据
// 拦截了读取数据 car Object { color: "blue" }

// delete proxyUser1.name
// 拦截了删除数据 name

// delete proxyUser1.car.color
// 拦截不到删除
// 拦截了读取数据 car {color: 'blue'}

const proxyUser2 = reactive({
    name: '小黑',
    car: {
        color: 'blue'
    }
})
// proxyUser2.name = '小绿' 
// 拦截了修改数据或添加属性 name 小绿

// proxyUser2.name += '=' 
// 拦截了读取数据 name 小黑  
// 拦截了修改数据或添加属性 name 小黑=

// proxyUser2.car.color = '='
// 拦截了读取数据 car Proxy {color: 'blue'}
// 拦截了修改数据或添加属性 color =

// delete proxyUser2.name
// 拦截了删除数据 name

delete proxyUser2.car.color
// 拦截了读取数据 car Proxy {color: 'blue'}
// 拦截了删除数据 color
```

#### 2) shallowRef 与 ref

```js
/*
自定义shallowRef
*/
function shallowRef(target) {
  const result = {
    _value: target, // 用来保存数据的内部属性
    _is_ref: true, // 用来标识是ref对象
    get value () {
      return this._value
    },
    set value (val) {
      this._value = val
      console.log('set value 数据已更新, 去更新界面')
    }
  }

  return result
}

/* 
自定义ref
*/
function ref(target) {
  if (target && typeof target==='object') {
    target = reactive(target)
  }

  const result = {
    _value: target, // 用来保存数据的内部属性
    _is_ref: true, // 用来标识是ref对象
    get value () {
      return this._value
    },
    set value (val) {
      this._value = val
      console.log('set value 数据已更新, 去更新界面')
    }
  }

  return result
}

/* 测试自定义shallowRef */
const ref3 = shallowRef({
  a: 'abc',
})
ref3.value = 'xxx'
ref3.value.a = 'yyy'


/* 测试自定义ref */
const ref1 = ref(0)
const ref2 = ref({
  a: 'abc',
  b: [{x: 1}],
  c: {x: [11]},
})
ref1.value++
ref2.value.b[0].x++
console.log(ref1, ref2)
```

#### 3) shallowReadonly 与 readonly

```js
// 定义handler处理器对象
const readonlyHandler = {
  get (target, prop) {
    const res = Reflect.get(target, prop)
    console.log('拦截到了读取数据', prop, res)
    return res
  },
  set (target, prop, value) {
    console.warn('只能读取数据,不能修改数据!')
    return true
  },
  deleteProperty (target, prop) {
    console.warn('只能读取数据,不能删除数据!')
    return true
  }
}

/* 
  自定义 shallowReadonly,传入要给目标对象
*/
function shallowReadonly (target) {
  // 判断当前数据是不是对象
  if (target && typeof target === 'object') {
    return new Proxy (target, readonlyHandler)
  }
  return target
}

/* 
  自定义 readonly,传入要给目标对象
*/
function readonly (target) {
  if (target && typeof target === 'object') {
    if (Array.isArray(target)) {
      target.forEach((item, index) => {
        target[index] = readonly(item)
      })
    } else {
      Object.keys(target).forEach((key) => {
        target[key] = readonly(target[key])
      })
    }
    return new Proxy (target, readonlyHandler)
  }
  return target
}
```

#### 4) isRef, isReactive 与 isReadonly

```js
/* 
判断是否是ref对象
*/
function isRef(obj) {
  return obj && obj._is_ref
}

/* 
判断是否是reactive对象
*/
function isReactive(obj) {
  return obj && obj._is_reactive
}

/* 
判断是否是readonly对象
*/
function isReadonly(obj) {
  return obj && obj._is_readonly
}

/* 
是否是reactive或readonly产生的代理对象
*/
function isProxy (obj) {
  return isReactive(obj) || isReadonly(obj)
}


/* 测试判断函数 */
console.log(isReactive(reactive({})))
console.log(isRef(ref({})))
console.log(isReadonly(readonly({})))
console.log(isProxy(reactive({})))
console.log(isProxy(readonly({})))
```

### 4. Composition API VS Option API

#### 1) Option API的问题

- 在传统的Vue OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 ，滚动条反复上下移动

#### 2) 使用Compisition API

我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起

## 9.2 其他新组合和API

### 1. 新组件

#### 1) Fragment（片段）

- 在Vue2中: 组件必须有一个根标签
- 在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中
- 好处: 减少标签层级, 减小内存占用

```vue
<template>
    <h2>aaaa</h2>
    <h2>aaaa</h2>
</template>
```

#### 2) Teleport（瞬移）

- Teleport 提供了一种干净的方法, 让组件的html在父组件界面外的特定标签(很可能是body)下插入显示

##### ModalButton.vue

```vue
<template>
  <button @click="modalOpen = true">
      Open full screen modal! (With teleport!)
  </button>

  <teleport to="body">
    <div v-if="modalOpen" class="modal">
      <div>
        I'm a teleported modal! 
        (My parent is "body")
        <button @click="modalOpen = false">
          Close
        </button>
      </div>
    </div>
  </teleport>
</template>

<script>
import { ref } from 'vue'
export default {
  name: 'modal-button',
  setup () {
    const modalOpen = ref(false)
    return {
      modalOpen
    }
  }
}
</script>

<style>
.modal {
  position: absolute;
  top: 0; right: 0; bottom: 0; left: 0;
  background-color: rgba(0,0,0,.5);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.modal div {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background-color: white;
  width: 300px;
  height: 300px;
  padding: 5px;
}
</style>
```

##### App.vue

```vue
<template>
  <h2>App</h2>
  <modal-button></modal-button>
</template>

<script lang="ts">
import ModalButton from './ModalButton.vue'

export default {
  setup() {
    return {
    }
  },

  components: {
    ModalButton
  }
}
</script>
```

#### 3) Suspense（不确定的）

- 它们允许我们的应用程序在等待异步组件时渲染一些后备内容，可以让我们创建一个平滑的用户体验

```vue
<template>
  <Suspense>
    <template v-slot:default>
      <AsyncComp/>
      <!-- <AsyncAddress/> -->
    </template>

    <template v-slot:fallback>
      <h1>LOADING...</h1>
    </template>
  </Suspense>
</template>

<script lang="ts">
/* 
异步组件 + Suspense组件
*/
// import AsyncComp from './AsyncComp.vue'
import AsyncAddress from './AsyncAddress.vue'
import { defineAsyncComponent } from 'vue'
const AsyncComp = defineAsyncComponent(() => import('./AsyncComp.vue'))
export default {
  setup() {
    return {
     
    }
  },

  components: {
    AsyncComp,
    AsyncAddress
  }
}
</script>
```

##### AsyncComp.vue

```vue
<template>
  <h2>AsyncComp22</h2>
  <p>{{msg}}</p>
</template>

<script lang="ts">

export default {
  name: 'AsyncComp',
  setup () {
    // return new Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     resolve({
    //       msg: 'abc'
    //     })
    //   }, 2000)
    // })
    return {
      msg: 'abc'
    }
  }
}
</script>
```

##### AsyncAddress.vue

```vue
<template>
<h2>{{data}}</h2>
</template>

<script lang="ts">
import axios from 'axios'
export default {
  async setup() {
    const result = await axios.get('/data/address.json')
    return {
      data: result.data
    }
  }
}
</script>
```

### 2. 其他新的API

#### 全新的全局API

+ createApp()
+ defineProperty()
+ defineAsyncComponent()
+ nextTick()

#### 将原来的全局API转移到应用对象

- app.component()
- app.config()
- app.directive()
- app.mount()
- app.unmount()
- app.use()

#### 模板语法变化

- v-model的本质变化
  - prop：value -> modelValue；
  - event：input -> update:modelValue；
- .sync修改符已移除, 由v-model代替
  - 
- v-if优先v-for解析

## 9.3 TODO LIST案例

## 9.4 Vue3的变化

+ 新增了三个组件：`Fragment` 支持多个根节点、`Suspense` 可以在组件渲染之前的等待时间显示指定内容、`Teleport` 可以让子组件能够在视觉上跳出父组件(如父组件overflow:hidden)
+ 新增指令 `v-memo`，可以缓存 html 模板，比如 v-for 列表不会变化的就缓存，简单说就是用内存换时间
+ 支持 `Tree-Shaking`，会在打包时去除一些无用代码，没有用到的模块，使得代码打包体积更小
+ 新增 `Composition API` 可以更好的逻辑复用和代码组织，同一功能的代码不至于像以前一样太分散，虽然 Vue2 中可以用 minxin 来实现复用代码，但也存在问题，比如方法或属性名会冲突，代码来源也不清楚等
+ 用 `Proxy` 代替 Object.defineProperty 重构了响应式系统，可以监听到数组下标变化，及对象新增属性，因为监听的不是对象属性，而是对象本身，还可拦截 apply、has 等13种方法
+ 重构了虚拟 DOM，在编译时会将事件缓存、将 slot 编译为 lazy 函数、保存静态节点直接复用(静态提升)、以及添加静态标记、Diff 算法使用 最长递增子序列 优化了对比流程，使得虚拟 DOM 生成速度提升 `200%`
+ 支持在 `<style></style>` 里使用 `v-bind`，给 CSS 绑定 JS 变量(`color: v-bind(str)`)
+ 用 `setup` 代替了 beforeCreate 和 created 这两个生命周期
+ 新增了**开发环境**的两个钩子函数，在组件更新时 `onRenderTracked` 会跟踪组件里所有变量和方法的变化、每次触发渲染时 `onRenderTriggered` 会返回发生变化的新旧值，可以让我们进行有针对性调试
+ 毕竟 Vue3 是用 `TS` 写的，所以对 `TS` 的支持度更好
+ Vue3 不兼容 `IE11`

# 10. 读书笔记

## 10.1 《你不知道的JavaScript（上卷）》

### 第一部分 作用域 和 闭包

#### 1. 作用域是什么

```js
* 作用域是根据名称查找变量的一套规则，用于确定在何处以及如何查找变量（标识符）。
* 引擎负责整个JavaScript程序的编译及执行过程。
LHS查询，查找要被赋值的变量（左边），函数中实参赋值给形参也是LHS。
RHS查询，查找变量的值（非左边）。
* 作用域嵌套，形成作用域链。
* javascript 语言层面只原生支持两种作用域类型：全局作用域 和 函数作用域 。全局作用域程序运行就有，函数作用域只有定义函数的时候才有，它们之间是包含的关系。
```

##### JS代码编译过程

```
词法分析（将代码打断为token） -> 语法分析（将token流转换为AST) => 生成机器指令（等待引擎执行）
https://juejin.cn/post/6844904165672484871#heading-1
```

#### 2. 词法作用域

```
词法作用域就是定义在词法阶段的作用域。
词法作用域，就意味着函数被定义的时候，它的作用域就已经确定了，和拿到哪里执行没有关系，因此词法作用域也被称为 “静态作用域”。
```

##### 欺骗（修改）词法作用域

###### eval & with

```js
eval()传入一个字符串，可以通过eval生成字符串中的代码并运行，就好像代码是写在那个位置一样
function foo (str, a) {
  eval(str)
  console.log(a, b)
}
var b = 2
foo('var b = 3', 1)
// 1 3
```

#### 3. 函数作用域和块作用域

```
函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。
立即执行函数IIFE
当可执行代码内部访问变量时，会先查找本地作用域，如果找到目标变量即返回，否则会去父级作用域继续查找...一直找到全局作用域。我们把这种作用域的嵌套机制，称为 作用域链。
javascript 中使用的是 “词法作用域”，因此函数作用域的范围在函数定义时就已经被确定，和函数在哪执行没有关系。
```

```
块作用域：
with
try/catch
let
const
```

#### 4. 提升

```
var提升
函数声明会被提升，函数表达式不会提升
函数声明会被提升到普通变量之前
```

#### 5. 作用域闭包

##### 内存泄漏的解决办法

```
1. 使用严格模式，避免不经意间的全局变量泄露
2. 避免过度使用闭包
3. 关注 DOM 生命周期，在销毁阶段记得解绑相关事件
```

### 第二部分 this 和 对象原型

### 1. 关于this

##### 为什么要用this & this的绑定

```js
* 隐式传递上下文，可以将API设计的更加优雅、简洁
* this 的绑定和函数声明的位置没有任何关系， 只取决于函数的调用方式
* 当一个函数被调用时， 会创建一个活动记录（有时候也称为执行上下文）。 这个记录会包含函数在哪里被调用（调用栈）、 函数的调用方法、 传入的参数等信息。 
this 就是记录的其中一个属性， 会在函数执行的过程中用到
```

#### 2. this全面解析

##### 调用位置 & 调用栈

```
调用栈： 为了到达当前执行位置所调用的所有函数
调用位置就在当前正在执行的函数的前一个调用中
```

##### 绑定规则

###### 1. 默认绑定

```js
function foo() {
  console.log( this.a );
}
var a = 2;
foo(); // 2
// 函数调用时应用了 this 的默认绑定， 因此 this 指向全局对象。
// 在代码中， foo() 是直接使用不带任何修饰的函数引用进行调用的， 因此只能使用默认绑定， 无法应用其他规则。
// 如果使用严格模式（strict mode）， 那么全局对象将无法使用默认绑定， 因此 this 会绑定到 undefined
```

###### 2. 隐式绑定

```js
function foo() {
  console.log( this.a );
}
var obj = {
  a: 2,
  foo: foo
};
obj.foo(); // 2
/ 调用 foo() 时 this 被绑定到 obj， 因此 this.a 和 obj.a 是一样的
---------------------------------------------------------------------------------------
function foo() {
  console.log( this.a );
}
var obj2 = {
  a: 42,
  foo: foo
};
var obj1 = {
  a: 2,
  obj2: obj2
};
obj1.obj2.foo(); // 42
// 对象属性引用链中只有最顶层或者说最后一层会影响调用位置
// foo()调用时的this,就是最后一层的obj2,obj2.a === this.a === 42
```

###### 隐式丢失

```js
一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象， 也就是说它会应用默认绑定， 从而把 this 绑定到全局对象或者 undefined 上， 取决于是否是严格模式
function foo() {
  console.log( this.a );
}
var obj = {
  a: 2,
  foo: foo
};
var bar = obj.foo; // 函数别名！
var a = "oops, global"; // a 是全局对象的属性
bar(); // "oops, global"
/ 虽然 bar 是 obj.foo 的一个引用， 但是实际上， 它引用的是 foo 函数本身， 因此此时的bar() 其实是一个不带任何修饰的函数调用， 因此应用了默认绑定。
--------------------------------------------------------------------------------------------------------------------------------
function foo() {
  console.log( this.a );
}
function doFoo(fn) {
  var a = 'doFoo中的a'
  // fn 其实引用的是 foo
  fn(); // <-- 调用位置！
}
var obj = {
  a: 2,
  foo: foo
};
var a = "oops, global"; // a 是全局对象的属性
doFoo( obj.foo ); // "oops, global"
/ 参数传递其实就是一种隐式赋值， 因此我们传入函数时也会被隐式赋值
--------------------------------------------------------------------------------------------------------------------------------
如果把函数传入语言内置的函数而不是传入你自己声明的函数，结果是一样的， 没有区别：
function foo() {
  console.log( this.a );
}
var obj = {
  a: 2,
  foo: foo
};
var a = "oops, global"; // a 是全局对象的属性
setTimeout( obj.foo, 100 ); // "oops, global"

JavaScript 环境中内置的 setTimeout() 函数实现和下面的伪代码类似：
function setTimeout(fn,delay) {
  // 等待 delay 毫秒
  fn(); // <-- 调用位置！
}
```

###### 3. 显式绑定

```js
call apply bind
```

###### 4. new绑定

```js
使用 new 来调用函数， 或者说发生构造函数调用时， 会自动执行下面的操作。
1. 创建（或者说构造） 一个全新的对象。
2. 这个新对象会被执行 [[ 原型 ]] 连接。
3. 这个新对象会绑定到函数调用的 this。
4. 如果函数没有返回其他对象， 那么 new 表达式中的函数调用会自动返回这个新对象。
```

##### 规则优先级

```js
* new绑定 > 显式绑定 > 隐式绑定 > 默认绑定
```

##### 绑定例外

###### 被忽略的this

```js
* 如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、 apply 或者 bind， 这些值在调用时会被忽略， 实际应用的是默认绑定规则：
function foo() {
  console.log( this.a );
}
var a = 2;
foo.call(null); // 2
// 什么情况下你会传入 null 呢？
// 一种非常常见的做法是使用 apply(..) 来“展开” 一个数组， 并当作参数传入一个函数。
// 类似地， bind(..) 可以对参数进行柯里化（预先设置一些参数）， 这种方法有时非常有用：
function foo(a,b) {
  console.log( "a:" + a + ", b:" + b );
}
/ 把数组“展开” 成参数
foo.apply( null, [2, 3] ); // a:2, b:3
/ 使用 bind(..) 进行柯里化
var bar = foo.bind( null, 2 );
bar( 3 ); // a:2, b:3

* 一种“更安全” 的做法是传入一个特殊的对象， 把 this 绑定到这个对象不会对你的程序产生任何副作用。 
可以传入空对象：Object.create(null)， 它和 {} 很 像， 但 是 并 不 会 创 建 Object.prototype 这个委托， 所以它比 {}“更空” 
function foo(a,b) {
  console.log( "a:" + a + ", b:" + b );
}
/ 我们的 DMZ 空对象
var ø = Object.create( null );
/ 把数组展开成参数
foo.apply( ø, [2, 3] ); // a:2, b:3
/ 使用 bind(..) 进行柯里化
var bar = foo.bind( ø, 2 );
bar( 3 ); // a:2, b:3
```

###### 间接引用

```js
* 另一个需要注意的是， 你有可能（有意或者无意地） 创建一个函数的“间接引用”， 在这种情况下， 调用这个函数会应用默认绑定规则
function foo() {
  console.log( this.a );
}
var a = 2;
var o = { a: 3, foo: foo };
var p = { a: 4 };
o.foo(); // 3
(p.foo = o.foo)(); // 2
/ 赋值表达式 p.foo = o.foo 的返回值是目标函数的引用， 因此调用位置是 foo() 而不是p.foo() 或者 o.foo()。 根据我们之前说过的， 这里会应用默认绑定。
```

##### this词法

###### 箭头函数

```js
* 箭头函数不使用 this 的四种标准规则， 而是根据外层（函数或者全局）作用域来决定 this。
function foo() {
// 返回一个箭头函数
  return (a) => {
    //this 继承自 foo()
    console.log( this.a );
  };
}
var obj1 = {
  a:2
};
var obj2 = {
  a:3
};
var bar = foo.call( obj1 );
bar.call( obj2 ); // 2, 不是 3 ！
/ foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。 由于 foo() 的 this 绑定到 obj1，bar（ 引用箭头函数） 的 this 也会绑定到 obj1， 箭头函数的绑定无法被修改。（new 也不行！ ）
--------------------------------------------------------------------------------------------------------------------------------
// 箭头函数最常用于回调函数中， 例如事件处理器或者定时器：
function foo() {
  setTimeout(() => {
    // 如果这里是普通函数，this就是undefined，绑定丢失
    // 这里的 this 在此法上继承自 foo()
    console.log( this.a );
  }, 0);
}
var obj = {
  a:2
};
foo.call( obj ); // 2
```

#### 3. 对象

##### 语法

##### 类型

##### 内容

###### 拷贝

```js
function anotherFunction() { /*..*/ }
var anotherObject = {
  c: true
};
var anotherArray = [];
var myObject = {
  a: 2,
  b: anotherObject, // 引用， 不是复本！
  c: anotherArray, // 另一个引用！
  d: anotherFunction
};
anotherArray.push( anotherObject, myObject );
如何深拷贝？
* 首先， 我们应该判断它是浅复制还是深复制。 对于浅拷贝来说， 复制出的新对象中 a 的值会复制旧对象中 a 的值， 也就是 2， 但是新对象中 b、 c、 d 三个属性其实只是三个引用， 它们和旧对象中 b、 c、 d 引用的对象是一样的。 对于深复制来说， 除了复制 myObject 以外还会复制 anotherObject 和 anotherArray。 这时问题就来了， anotherArray 引用了 anotherObject 和myObject， 所以又需要复制 myObject， 这样就会由于循环引用导致死循环。
* 对于 JSON 安全（也就是说可以被序列化为一个 JSON 字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象） 的对象来说， 有一种巧妙的复制方法：
  var newObj = JSON.parse( JSON.stringify( someObj ) );
--------------------------------------------------------------------------------------------------------------------------------
浅拷贝：
ES6 定义了 Object.assign(..) 方法来实现浅复制。 Object.assign(..) 方法的第一个参数是目标对象， 之后还可以跟一个或多个源对象。 它会遍历一个或多个源对象的所有可枚举（enumerable， 参见下面的代码）的自有键（owned key， 很快会介绍） 并把它们复制（使用 = 操作符赋值） 到目标对象， 最后返回目标对象， 就像这样：
var newObj = Object.assign( {}, myObject );
newObj.a; // 2
newObj.b === anotherObject; // true
newObj.c === anotherArray; // true
newObj.d === anotherFunction; // true
```

###### 属性描述符

```js
var myObject = {
  2
};
Object.getOwnPropertyDescriptor( myObject, "a" );
// {
// value: 2,
// writable: true,
// enumerable: true,
// configurable: true
// }
这个普通的对象属性对应的属性描述符不仅仅只是一个 2。 它还包含另外三个特性： writable（ 可写）、enumerable（可枚举） 和 configurable（可配置）。
具体参见3.10.2的defineProperty()中对属性描述符的笔记
```

##### 遍历

###### 给对象添加iterator

```js
var myObject = {
  a: 2,
  b: 3
};
Object.defineProperty( myObject, Symbol.iterator, {
  enumerable: false,
  writable: false,
  configurable: true,
  value: function() {
    var o = this;
    var idx = 0;
    var ks = Object.keys( o );
    return {
      next: function() {
        return {
          value: o[ks[idx++]],
          done: (idx > ks.length)
        };
      }
    };
  }
});
// 手动遍历 myObject
var it = myObject[Symbol.iterator]();
it.next(); // { value:2, done:false }
it.next(); // { value:3, done:false }
it.next(); // { value:undefined, done:true }
// 用 for..of 遍历 myObject
for (var v of myObject) {
  console.log( v );
}
// 2
// 3
```

## 



























